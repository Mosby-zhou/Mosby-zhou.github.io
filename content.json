{"pages":[{"title":"","text":"About me","link":"/about/index.html"}],"posts":[{"title":"人工神经网络和反向传播算法","text":"最近因为人机大战, 人工智能火得不行, 作为技术人员, 自然对这种终极技术产生了一定的兴趣, 翻了一些论文看了一些文档以后, 在这里记录一点学习心得吧. 人工智能原理人工智能, 这个标题好像很厉害的样子, 实际上原理很简单, 就是一个强大的神经网络. 而神经网络又好像很厉害的样子, 下面就来看看神经网络是什么东西. 神经网络基本概念在深度学习中的神经网络, 和人体的神经网络一点关系都没有, 只是一个相似的名词而已. 这里的神经网络是由很多个神经节点构成, 可能有多层, 每层有n个, 就像n维数组一样, 每个神经节点都是一个多参数函数, 返回值是和下一层网络节点数量相同的sigmoid函数值. 同一层的每个节点的输出值经过求权和相加以后, 作为下一层的参数以供计算. 这便是神经网络最基本的实现方式. 原理在宇宙中, 大概除了量子存在海森堡测不准原理以外, 其他的都是可测量和计算的. 如万有引力, 牛顿定律, E=mc^2等. 这种是简单的原理, 上升到复杂一点的, 如火箭升空, 需要多大的推动力, 能带多少燃料和多少负载, 能飞到什么地方和什么时候到, 都是可以计算出来的, 只是需要的条件和参数比较多. 以此类推到更复杂的情况, 可以得到, 任何事情或者说是变化都是可以计算出来的, 只是需要你传入准确的参数. 而在以前, 这些计算方法都是由人类创造和推出, 而在神经网络中, 是由算法和数据生成. 如以前的天气预报, 是通过各种风力风向温度湿度等, 传入一个复杂计算函数中得到结果, 往往会出现不准确的情况, 因为计算函数不完善, 而这种计算函数又是很难构建完善的. 而现在出现了人工智能加大数据分析预测天气情况, 比以前准确了许多, 而且会一直进化和提升. 假设以前的计算方法为, 指定一个函数f(x1,x2,x3...) = ax1 + bx2 + cx3 + ..., 传入足够的值来得到结果, 那么里面的参数列表a,b,c等值是通过历史数据计算得来. 计算参数起来就会特别复杂和麻烦, 而且并不能动态生成这个函数, 而神经网络则是类似这样, 不过是生成一个动态的参数表格. 先来看看单个的神经元, 为了方便计算和得出结果, 需要使神经元的输入值都为(0,1), 输出值也为(0,1), 这样在计算结果时, 接近1的为真, 接近0的为假. 为了将任意值都转换为(0,1)的形式, 需要定义一个sigmoid函数, sigmoid(z) = 1 / (1 + e^-z). 当输入值为很大的正数时, 那么e^-z值为很小, 函数返回值接近1, 当输入值为很大的负数时, e^-z变大, 函数返回值接近0, 而在中间值变化时, 该函数返回值也是平滑的, 所以可以比较好的模拟(0,1)的返回值. 不过如果你需要, 也可以实现一个其他的sigmoid函数, 只要返回值为平滑的(0,1)即可. 在看传入sigmoid函数的参数, 应该是传入值和该神经元初步计算得到的值. 表示为f(x1,x2...) = a1x1 + a2x2 + ... + b. 所以确定一个神经元, 只需要确定它的a1-an的值, 和偏移量b即可. 然后来看一个最简单的单层神经网络, 有一个输入层, 一个处理层, 一个输出层. 输入层输入值为{x1,x2,x3,x4}, 处理层有3个神经元, 那么它们的处理函数应该是f[a1](x1,x2,x3,x4) = sigmoid(a1a1 * x1 + a1a2 * x2 + a1a3 * x3 + a1a4 * x4 + a1b), f[a2](x1,x2,x3,x4) = sigmoid(a2a1 * x1 + a2a2 * x2 + a2a3 * x3 + a2a4 * x4 + a2b), f[a3](x1,x2,x3,x4) = sigmoid(a3a1 * x1 + a3a2 * x2 + a3a3 * x3 + a3a4 * x4 + a3b), 输出层只有一个神经元, 处理函数f[b1](xa1,xa2,xa3) = sigmoid(b1a1 * xa1 + b1a2 * xa2 + b1a3 * xa3 + b1b). 假设上面的神经网络是对真实情况的反应, 设y(x)为真实输出, f(x)为神经网络的输出. 在给定x的情况下, 需要找到合适的参数, 使f(x)值尽量等于y(x)的值. 那么问题就变成: 需要一个算法, 找到所有的参数an和bnb, 是输出值尽量靠近真实值. 为了知道如何才算靠近真实值, 需要定义一个代价函数: C(w,b) = E(x)(||y(x) - a||^2) / 2n, 这里面的a即为f(x)计算得到的值, E(x)(...)即为对所有的x值求和, 反映到实际即对于所有训练数据x, n为训练数据数量, 得到一个整体训练数据的误差, w为所有an的向量, b代表偏移. 而训练神经网络的目标, 便是让C(w,b)变得尽可能小. 现在, 将输入值x向量化看待, 每层的输入值为xn = {xn1,xn2,xn3,xn4}, 每层的计算函数为wn = {{a1a1,a1a2,a1a3,a1a4},{a2a1,a2a2,a2a3,a2a4},{a3a1,a3a2,a3a3,a3a4}}, 偏移量为bn = {b1b,b2b,b3b}, 那么在计算输出值的时候, 使用向量计算, 即可得到输出值f(x) = sigmoid(wn * xn + bn), 那么计算该层的输出值即为f(xi) = sigmoid(wn * x[i-1] + bn), 令z[i] = wn * x[i-1] + bn, 那么f(xi) = sigmoid(z[i]), 令z[i][j]为第[i]层的第[j]个值, 那么z[a][1]为第a层第1个值, 即为f[a1](x1,x2,x3,x4)所计算的值, 即z[a][1] = a1a1 * x1 + a1a2 * x2 + a1a3 * x3 + a1a4 * x4 + a1b, 那么z[i][j] = E(k)(a[i]a[j][k] * x[k]) + b[i][j]. 下面来看看反向传播算法的含义吧. 假设在训练好的神经网络中, 每个神经元都有正确的参数, 而第i层第j个神经元被人为改变成了错误的参数. 那么在输入x的值时, 在计算结果经过这个神经元的时候, 值与原来的正确值有一点改变, 设改变值为Δz[i][j], 这就导致了神经元输出变成了f[i][j](x) = sigmoid(z[i][j] + Δz[i][j]). 这个改变将会在后续的网络中传播, 导致全部代价改变. 因为原始的代价函数为C = (y - a)^2 / 2, a = E(i,j)(z[i][j]), 那么代价改变值可以表示为ΔC = C′ * Δz[i][j], 那么C′ = d(C) / d(z[i][j]). 可以看出, 如果改变Δz[i][j], 便可以使C变化, 如果正确的改变Δz[i][j], 可以使得C值变小. 设第i层第j个神经元的错误量为δij = d(c) / d(z[i][j]), 那么它对i+1层的第 n 个神经元影响为a[i + 1][n] * δij. 在训练神经网络中, 参数计算是靠梯度批量下降法来寻找合适参数的, 那么便需要求误差函数对每个权重a和偏移b的偏导数. 如果是正常求值, 那么需要从输入节点开始, 将每个节点对下个节点的影响导数求出, 一直求到对最终结果的影响. 然后再根据最终结果对每个节点的偏导值, 来调整它们的权重和偏导数. 而反向传播算法则是改进这个计算方法的算法. 反向传播从最后一层节点开始计算它之前的每个节点对它的影响, 然后再依次前推, 那么一次性就能计算出所有的节点对最后一个节点的偏导值, 极大的简化了求值速度. 这便是反向传播的核心思想, 即快速计算出最终结果对每个节点参数的偏导值, 然后再根据梯度下降算法来更新每个节点的参数, 从而降低C的值, 进化神经网络. 而具体如何实现, 又是一个比较大的内容了, 可以参考这篇文章, 使用python实现一个简单的神经网络来识别图片.","link":"/2016/2016-03-13-ann-and-backpropagation/"},{"title":"动态规划算法","text":"在以前做ACM的时候, 总是绕不开DP算法解题, 刚好又在项目里遇到了, 就总结一下吧. DP算法又叫动态规划算法, 从字面可以看出它是动态的. 那么是什么样的动态呢, 可以这样理解: 根据之前的计算结果动态决定下一步的计算结果. 从一个简单的题目开始: 使用1,3,5三个数, 组成13, 需要的数字最少的方案. 一眼就能看出来是5 + 5 + 3. 那么从算法角度来看看这个是怎么实现的吧. 要判断13由多少构成, 那么就可以把问题看成为: 12, 10, 8这三个数分别最小由多少构成. 这样可以一直推到最小值1. 那么算法的步骤即从1开始计算最小构成值为多少. 123456789101112131415160 = 0 -&gt; 0不需要参数即可构成1 = 0 + 1 =&gt; [1] -&gt; 1个(1)即可构成2 = 1 + 1 =&gt; [2] -&gt; 第一个(1)是上一步的计算值, 第二个(1)是其中一个数3 = 2 + 1 =&gt; [3]/ 0 + 3 =&gt; [1] -&gt; 2 + 1中, (2)是上一步的计算值, 这里出现了分化, 3 可以由3个值构成, 也可以由1个值构成, 那么取小, 由1个值构成的供之后计算4 = 3[1] + 1 =&gt; [2]/ 1[1] + 3 =&gt; [2]5 = 4[2] + 1 =&gt; [3]/ 2[2] + 3 =&gt; [3]/ 0[0] + 5 =&gt; [1] -&gt; 取小值16 = 5[1] + 1 =&gt; [2]/ 3[1] + 3 =&gt; [2]/ 1[1] + 5 =&gt; [2]7 = 6[2] + 1 / 4[2] + 3 / 2[2] + 5 =&gt; [3]8 = 7[3] + 1 / 5[1] + 3 / 3[1] + 5 =&gt; [2]9 = 8[2] + 1 / 6[2] + 3 / 4[2] + 5 =&gt; [3]10 = 9[3] + 1 =&gt; [4]/ 7[3] + 3 =&gt; [4]/ 5[1] + 5 =&gt; [2] -&gt; 取小值211 = 10[2] + 1 / 8[2] + 3 / 6[2] + 5 =&gt; [3]12 = 11[3] + 1 / 9[3] + 3 / 7[3] + 5 =&gt; [4]13 = 12[4] + 1 =&gt; [5]/ 10[2] + 3 =&gt; [3]/ 8[2] + 5 =&gt; [3] -&gt; 取小值3而且可以从构成中看见, 13 = 10 + 3 / 8 + 5, 10 = 5 + 5, 8 = 5 + 3 这便是动态规划算法的原理, 现在用代码来实现一遍: 1234567891011121314int lis(int n){ //计算n由最少多少个数字构成 int *d = new int[n + 1]; //计算出0-n的全部 int a[] = {1, 3, 5}; d[0] = 0; //和为0的时候不需要元素构成 for (int i = 1; i &lt;= n; i++){ //从i计算到n d[i] = d[i - 1] + 1; //1为最小元素, 默认为前一个值减最小值加1 for (int j = 0; j &lt; 3; j++){ //循环所有元素 if (a[j] &lt;= i &amp;&amp; d[i - a[j]] + 1 &lt; d[i]){ // 如果n-某元素所需要的构成比当前构成小, 那么取小的构成 d[i] = d[i - a[j]] + 1; } } } return d[n]; // 返回构成的最小值} 接下来看一个复杂一点的问题: 有编号分别为 a,b,c,d,e 的五件物品, 它们的重量分别是 2,2,6,5,4, 它们的价值分别是 6,3,5,4,6, 现在给你个承重为 10 的背包, 如何让背包里装入的物品具有最大的价值总和. 同样的计算方式: 1234567891011121314151617181920212223242526272829303132int lis(int n){ //计算 n 重量时的最大价值int w[] = { 0, 4, 5, 6, 2, 2 };int v[] = { 0, 6, 4, 5, 3, 6 };int w*length = getArrayLen(w);int \\*\\_d = new int*[w_length];for (int i = 0; i &lt; w_length; i++){d[i] = new int[n + 1]; // 计算出 0-n 的全部}for (int i = 0; i &lt; n + 1 || i &lt; w_length; i++){if (i &lt; n + 1){d[0][i] = 0; // 初始化 0-0 的元素值为 0}if (i &lt; w_length){d[i][0] = 0; // d[x][n]表示放置之前的 x 号物体时, n 承重的时候的价值}}for (int i = 1; i &lt; n + 1; i++){ // 主循环for (int j = 1; j &lt; w_length; j++){ // 遍历每个物体, 填充 d[x], 即当前含有前 j 个物体时的计算承重价值if (i &gt;= w[j]){ // 如果当前承重大于物品重量int a = d[j - 1][i]; // a 为 放置上一个物体时, 承重的价值int b = d[j - 1]i - w[j]] + v[j]; // b 为 放置之前的物体情况下, 如果承重减去当前物体承重, 再加上当前物体的价值 的价值d[j][i] = a &gt; b ? a : b; // 取价值比较大的值}else{ // 如果当前承重小于物品重量, 那么直接和上一个承重的价值相等d[j][i] = d[j - 1][i];}}}return d[w_length - 1][n]; // 放置全部物体的情况下, n 承重的价值}printf(&quot;%4d\\n&quot;, lis(10)); // -&gt; 15","link":"/2016/2016-06-27-dp-dynamic-programming-algorithm/"},{"title":"angularjs provider的区别和使用","text":"moduleangular 可以对一个 module 使用.config 方法来配置这个模块, config 可以注入一个$provide对象, 所有的配置都是通过$provide 的方法调用的.$provide 下有六个方法: provider factory service value constant decorator 它们都有自己的语法糖, 即不是通过.config(['$provide', function($provide){}])调用. providerprovider是最重要的一个方法, 了解provider以后, 会发现factory, service, value三个方法只是provider的语法糖. provieder的源码:123456789function provider(name, provider_) { if (isFunction(provider_) || isArray(provider_)) { provider_ = providerInjector.instantiate(provider_); } if (!provider_.$get) { throw Error('Provider ' + name + ' must define $get factory method.'); } return (providerCache[name + providerSuffix] = provider_);} name是这个 provider 的名称, 在整个 app 里面应该唯一, 否则会覆盖. 如果第二个参数是数组, 则按依赖注入前面的参数, 解析最后一个函数, 如果是函数, 则直接解析. 这两种解析方式函数返回的对象都应该是一个有$get方法的对象. 可以说provider是一个可配置的factory, 可以存在其他配置对象并通过闭包使用. 在 return 地方可以看到, angular 对所有的 provider 都做了缓存, 所以 provider 都是单例模式的, 包括下面的factory, service, value. factory源码:123function factory(name, factoryFn) { return provider(name, { $get: factoryFn });} 简单点说就是生成一个 factory 对象, 对象的属性是 factoryFn 里面 return 的任意值. service源码:12345678function service(name, constructor) { return factory(name, [ '$injector', function ($injector) { return $injector.instantiate(constructor); }, ]);} 和 factory 基本没区别, 只是通过 new 方式调用的, 你可以在 constructor 函数里面直接对 this 设置值(注意通过 this 设置值的时候不能有 return). 也可以和 factory 一样 return 一个对象.区别是通过 this 设置值的时候, 会显示原型(在我们项目里面, 只有 service, 大部分也是 return 对象, 原因是…名字比 factory 易懂…). value源码:12345678function value(name, value) { return factory(name, valueFn(value));}function valueFn(value) { return function () { return value; };} 很简单, 返回一个常量. constant源码:1234function constant(name, value) { providerCache[name] = value; instanceCache[name] = value;} 和 value 的区别是, 不通过 factory 调用, 即配置完成以后就存在了, 可以在 config 里面注入. 而且是在配置完成的时候立即加载运行的.通过代码也可以看到constant也是单例模式, 通过缓存读取的. 123456789101112131415161718192021222324252627app.constant('myConstant', '1');app.config([ 'myConstant', '$provide', function (myConstant, $provider) { console.log(myConstant); },]);//有效app.value('myValue', '1');app.config([ 'myValue', '$provide', function (myValue, $provider) { console.log(myValue); },]);//报错app.value('myValue', '1');app.config([ 'myValueProvider', '$provide', function (myValueProvider, $provider) { console.log(myValueProvider); },]);//有效, 获取的是provider对象, 而不是$get的值, 所以在部分情况下定义provider的属性可以在config里面获取得到. decorator装饰器模式的实现. 可以对 provider 对象进行装饰. 源码:12345678function decorator(serviceName, decorFn) { var origProvider = providerInjector.get(serviceName + providerSuffix), orig$get = origProvider.$get; origProvider.$get = function () { var origInstance = instanceInjector.invoke(orig$get, origProvider); return instanceInjector.invoke(decorFn, null, { $delegate: origInstance }); };} 简单点说就是把上面通过provider创建的 provide 的$get 方法替换成新的decorFn, 可以达到运行时修改 service 的功能. 实际使用的情况并不多见. 不能对constant定义的值使用, 因为constant不是通过provider创建的, 但能对value 使用. 多次使用decorator对于某个provider来说, 使用过decorator以后, 这个provider的$get方法已经变成decorator里面替换的$get了, 所以再次使用decorator的时候, 等于对改变过的$get使用decorator, 即会造成叠加而不是替换的效果. 这点和provider重复声明会替换不同. $injectorangular.injector()可以获得注入器, 如果有引入 jquery, 则$.fn.injector()也可以使用. $injector.has('serviceName')可以判断是否存在这个服务. $injector.get('serviceName')可以通过服务名获得服务对象. $injector.annotate(ctrls)可以获得 ctrls 的依赖对象.","link":"/2016/2016-08-18-angularjs-provider/"},{"title":"一个angular指令加载顺序异常的排除","text":"起因在表格展示的时候, 有些状态需要切换的, 之前都是直接使用的 checkbox. 有天老大说要优化界面, 把大部分的 checkbox 换成仿 iOS 的 SwitchButton, 开始想得很简单嘛, 新建了一个指令, 考虑了下使用场景和情况, 减少使用成本, 使用方法和原始 input 差不多, 很快就完工了. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var switchBtn = function () { return { restrict: 'A', templateUrl: 'views/common/switchBtn.html', css: { href: 'styles/common/switchBtn.css', persist: true }, replace: true, scope: { //传入的ng-model至少是双层结构(至少有个.) ngModel: '=', firstStatus: '@', onChange: '=', text: '=', noText: '=', item: '=', }, controller: function ($scope) {}, link: function ($scope, $element, $attrs) { $element.on('selectstart', function () { return false; }); var firstStatus = false; if ($scope.firstStatus &amp;&amp; $scope.firstStatus.toLowerCase() == 'false') { firstStatus = false; } else if ($scope.firstStatus &amp;&amp; $scope.firstStatus.toLowerCase() == 'true') { firstStatus = true; } if (typeof $scope.ngModel != 'undefined' &amp;&amp; $scope.ngModel != null) { $scope.ngModel = firstStatus || $scope.ngModel; } else { $scope.ngModel = firstStatus; } if ($scope.noText) { $scope.text = ['', '']; } else if (!$scope.noText &amp;&amp; !$scope.text) { $scope.text = ['on', 'off']; } $scope.changeSwitch = function () { $scope.ngModel = !$scope.ngModel; if ($scope.onChange) { if ($scope.onChange($scope.ngModel, $scope.item) == false) { $scope.ngModel = !$scope.ngModel; } } }; $scope.getText = function () { return $scope.text[$scope.ngModel ? 0 : 1]; }; }, };}; 1234&lt;div class=&quot;switch-select&quot; ng-click=&quot;changeSwitch()&quot;&gt; &lt;div class=&quot;switch-bg&quot; ng-class=&quot;{true:'on',false:'off'}[ngModel]&quot;&gt;&lt;span ng-bind=&quot;getText()&quot;&gt;&lt;/span&gt;&lt;/div&gt; &lt;div class=&quot;switch-btn&quot; ng-class=&quot;{true:'on',false:'off'}[ngModel]&quot;&gt;&lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117/*按钮大小不符合可根据需要在相关页面css自定义大小*//* demo:.[class] .switch-select { width: 45px; height: 16px; } .[class] .switch-bg { border-radius: 18px; font-size: 12px; } .[class] .switch-bg span { top: 1px; } .[class] .switch-bg.on span { left: 6px; } .[class] .switch-bg.off span { right: 6px; } .[class] .switch-btn { top: 1px; height: 14px; width: 14px; } .[class] .switch-btn.on { left: 30px; } .[class] .switch-btn.off { left: 1px; }*/.switch-select { position: relative; display: inline-block; vertical-align: top; width: 45px; height: 16px; cursor: pointer;}.switch-bg { height: 100%; width: 100%; color: #fff; border-radius: 18px; font-size: 12px; text-transform: uppercase; transition: All 0.3s ease; -webkit-transition: All 0.3s ease; -moz-transition: All 0.3s ease; -o-transition: All 0.3s ease;}.switch-bg span { position: absolute; top: 1px; line-height: 1;}.switch-bg.on { background-color: #00af2c; border: 1px solid #068506;}.switch-bg.on span { left: 6px;}.switch-bg.off { background-color: #ed5b49; border: 1px solid #d2402e;}.switch-bg.off span { right: 6px;}.switch-btn { transition: All 0.3s ease; -webkit-transition: All 0.3s ease; -moz-transition: All 0.3s ease; -o-transition: All 0.3s ease; background: #eee; background: linear-gradient(#eee, #fafafa); border-radius: 100%; height: 14px; position: absolute; top: 1px; width: 14px;}.switch-btn.on { left: 30px;}.switch-btn.off { left: 1px;}.switch-btn .switch-btn-content { background: #dedede; background: linear-gradient(#dedede, #cacaca); border-radius: 50%; height: 9px; width: 9px; margin-top: 5px; margin-left: 5px; padding: 0;} 加入文件, 替换 input, 简单好用, 给老大看效果也还不错, 写好文档和使用方法,&lt;div switch-btn ng-model=&quot;item.isTagEnum&quot; no-text=&quot;true&quot;&gt;&lt;/div&gt;交差完工. 问题过了两天, 突然发现在表单里面刚刚加载完表单以后点击按钮没有反应, 需要等个 2-3s 才有事件. 开始以为是 ng-repate 的性能问题, 一个 repeat 里面指令太多, 试试 trackby - 无效, 试试减少其他元素(因为之前对填入的数据都加了一个 autoInputTips 的)- 无效, 最后发现只是循环这一个指令都比较慢, 而且数据量越少越快, 感觉很奇怪, 断点到指令的 link, 也发现 link 加载顺序不对, 大概有 2-3s 延迟才执行这个指令的 link, 换成其他指令, 即使很复杂的, 也没有出现加载缓慢的情况. 排查仔细排查这个指令和其他指令的不同…一点点删改, 发现删除了css: { href: 'styles/common/switchBtn.css', persist: true },之后, 指令加载就正常了. 确定是 angularcss 的问题. 给指令加 compile. 去看 network, 发现 css 请求是在 controller 和 prelink 执行完了以后执行的, 于是感觉是因为 css 延迟加载导致指令加载顺序异常. 原理去看 angularcss 源码, 在 650 行左右 123456789101112131415161718var directive = $delegate[0];var compile = directive.compile;if (!directive.css) { directive.css = $directive.css;}directive.compile = function () { var link = compile ? compile.apply(this, arguments) : false; return function (scope) { var linkArgs = arguments; $timeout(function () { if (link) { link.apply(this, linkArgs); } }); $rootScope.$broadcast('$directiveAdd', directive, scope); };};return $delegate; 果然如同猜想, 在指令有 css 的时候, angularcss 改写指令的 compile 方法, 返回的新的 postlink 在$timeout 函数里面执行原始的 link, 所以才导致了 link 函数加载顺序异常. 解决确定原因以后解决起来就简单了, 去掉组件的独立引用 css, 合并到 common.scss 里面, 在 index 里面引入. 顺便提醒各项目组尽量少使用独立的 angularcss, 而且只在各自的顶级指令里面使用 angularcss, 会改变加载顺序而且由于使用 timeout, 会影响性能. 后记 改完以后基本使用没问题, 性能也还 ok, 因为也使用的 ng-model 传入值, 用起来感觉和原始 input 差不多, 但是有个问题, 传入的值如果不是对象而是值的时候, 会因为改变的是值而不是对象绑定不到原始值上. 比如&lt;div switch-btn ng-model=&quot;isDisplay&quot; no-text=&quot;true&quot;&gt;&lt;/div&gt;在 switchBtn 指令里面改变$scope.isDel 的值则不会改变原始 scope 里的值, 因为这样传递 scope 是值传递. 那怎么解决呢? 很简单, 用$scope.$parent 来取到原始节点的 scope, 然后改变值就可以了. 123if (!/\\./.test(attr['ngModel'])) { $scope.$parent[attr['ngModel']] = value;} 看到这里可能有人有疑惑… 如果在 ngIf 下面使用, 还是会绑定不到值啊?是的… 可是原本的 input NgModel 就存在这个问题, 为了统一, 也不准备修复原理是 ngIf 创建了自己的$scope:true 的原型继承作用域, 虽然可以通过原型拿到值, 但是绑定的时候还是绑定不到原型链上的. 后记的后记 后来我用的时候嫌麻烦, 改成了最简单的 css 实现. 效果: .mui-switch { width: 52px; height: 31px; position: relative; border: 1px solid #dfdfdf; background-color: #fdfdfd; box-shadow: #dfdfdf 0 0 0 0 inset; border-radius: 20px; border-top-left-radius: 20px; border-top-right-radius: 20px; border-bottom-left-radius: 20px; border-bottom-right-radius: 20px; background-clip: content-box; display: inline-block; -webkit-appearance: none; -moz-appearance: none; user-select: none; outline: none; } input[type=\"checkbox\"].mui-switch:focus { outline: #fff none 0; } .mui-switch:before { content: ''; width: 29px; height: 29px; position: absolute; top: 0px; left: 0; border-radius: 20px; border-top-left-radius: 20px; border-top-right-radius: 20px; border-bottom-left-radius: 20px; border-bottom-right-radius: 20px; background-color: #fff; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4); } .mui-switch:checked { box-shadow: #64bd63 0 0 0 16px inset; /*border-color: #64bd63; background-color: #64bd63;*/ border-color: #52a4ff; background-color: #52a4ff; } .mui-switch:checked:before { left: 21px; } .mui-switch.mui-switch-animbg { transition: background-color ease 0.4s; } .mui-switch.mui-switch-animbg:before { transition: left 0.3s; } .mui-switch.mui-switch-animbg:checked { box-shadow: #dfdfdf 0 0 0 0 inset; /*background-color: #64bd63;*/ background-color: #52a4ff; transition: border-color 0.4s, background-color ease 0.4s; } .mui-switch.mui-switch-animbg:checked:before { transition: left 0.3s; } .mui-switch.mui-switch-anim { transition: border cubic-bezier(0, 0, 0, 1) 0.4s, box-shadow cubic-bezier(0, 0, 0, 1) 0.4s; } .mui-switch.mui-switch-anim:before { transition: left 0.3s; } .mui-switch.mui-switch-anim:checked { /*box-shadow: #64bd63 0 0 0 16px inset; background-color: #64bd63;*/ box-shadow: #52a4ff 0 0 0 16px inset; background-color: #52a4ff; transition: border ease 0.4s, box-shadow ease 0.4s, background-color ease 1.2s; } .mui-switch.mui-switch-anim:checked:before { transition: left 0.3s; } .mui-switch.mui-switch-middle { height: 26px; width: 44px; } .mui-switch.mui-switch-middle:before { width: 24px; height: 24px; } .mui-switch.mui-switch-middle:checked:before { left: 18px; } } } 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124.mui-switch { width: 52px; height: 31px; position: relative; border: 1px solid #dfdfdf; background-color: #fdfdfd; box-shadow: #dfdfdf 0 0 0 0 inset; border-radius: 20px; border-top-left-radius: 20px; border-top-right-radius: 20px; border-bottom-left-radius: 20px; border-bottom-right-radius: 20px; background-clip: content-box; display: inline-block; -webkit-appearance: none; -moz-appearance: none; user-select: none; outline: none;}input[type='checkbox'].mui-switch:focus { outline: #fff none 0;}.mui-switch:before { content: ''; width: 29px; height: 29px; position: absolute; top: 0px; left: 0; border-radius: 20px; border-top-left-radius: 20px; border-top-right-radius: 20px; border-bottom-left-radius: 20px; border-bottom-right-radius: 20px; background-color: #fff; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);}.mui-switch:checked { box-shadow: #64bd63 0 0 0 16px inset; /*border-color: #64bd63; background-color: #64bd63;*/ border-color: #52a4ff; background-color: #52a4ff;}.mui-switch:checked:before { left: 21px;}.mui-switch.mui-switch-animbg { transition: background-color ease 0.4s;}.mui-switch.mui-switch-animbg:before { transition: left 0.3s;}.mui-switch.mui-switch-animbg:checked { box-shadow: #dfdfdf 0 0 0 0 inset; /*background-color: #64bd63;*/ background-color: #52a4ff; transition: border-color 0.4s, background-color ease 0.4s;}.mui-switch.mui-switch-animbg:checked:before { transition: left 0.3s;}.mui-switch.mui-switch-anim { transition: border cubic-bezier(0, 0, 0, 1) 0.4s, box-shadow cubic-bezier(0, 0, 0, 1) 0.4s;}.mui-switch.mui-switch-anim:before { transition: left 0.3s;}.mui-switch.mui-switch-anim:checked { /*box-shadow: #64bd63 0 0 0 16px inset; background-color: #64bd63;*/ box-shadow: #52a4ff 0 0 0 16px inset; background-color: #52a4ff; transition: border ease 0.4s, box-shadow ease 0.4s, background-color ease 1.2s;}.mui-switch.mui-switch-anim:checked:before { transition: left 0.3s;}.mui-switch { &amp;.mui-switch-middle { height: 26px; width: 44px; &amp;:before { width: 24px; height: 24px; } &amp;:checked { &amp;:before { left: 18px; } } } &amp;.mui-switch-small { height: 22px; width: 36px; &amp;:before { width: 20px; height: 20px; } &amp;:checked { &amp;:before { left: 14px; } } }} 1&lt;input class=&quot;mui-switch mui-switch-animbg mui-switch-middle&quot; type=&quot;checkbox&quot; ng-model=&quot;item.isDisplay&quot; /&gt;","link":"/2016/2016-09-04-angularjs-css-directive-link-error/"},{"title":"angular的异步加载组件以及路由使用","text":"ui-router应该可以算angular最重要的组件之一了, 简单易用, 不过它的template基于controller的做法不太符合我们项目里directive-first的原则, 而且它的异步加载模块ocLazyLoad语法不太好用, 需要配置在 app 初始化的config中, 不能实现动态配置和动态读取. 所以之前自己实现了一个建议版本的异步加载模块指令, 供项目组使用. angular-async-module加入了动态加载读取模块, 也可以和ui-router分离使用, 可以对加载开始和结束的行为进行事件响应. 对于router, 不建议使用controller来控制模版行为, 而建议使用指令来控制模版. 一般是一个router对应一个module, 根据需求可选这个module是否异步.angular-async-module对于模块的加载是基于ng-include指令的, 页面需要为一个模版页, 正常情况会包含展示的自定义指令, 用&lt;!-- script: asyncDemo/asyncDemoMod --&gt;这种语法导入所需module的scrpit, 可以支持一个模版导入多个文件模块. 指令加载是在模块导入完成以后加载到页面上, 提供生命周期钩子函数, 可以自由控制加载时页面内容. 详细可见项目demo.","link":"/2016/2016-10-23-angularjs-async-module/"},{"title":"angular的eval与watch","text":"angular 给开发人员提供了很多内部使用的强大的工具函数, $parse服务和$observe就是其中两个比较有用的函数. $parse$parse作为一个服务, 在使用的时候需要先注入到指令中, 它的作用是把一个字符串编译成一个解释器函数(也可传入一个函数, 不过和直接声明函数没区别), 再对指定的scope操作即可. 生成的函数有两个参数, 一个是context, 另一个是locals(可选), context即表达式里面的属性所在的对象, locals如果提供, 可以覆盖context里面重名的属性. 1234567891011121314151617$scope.context = { add: function (a, b) { return a + b; }, mul: function (a, b) { return a * b; }, a: 1, b: 2,};$scope.locals = { a: 3, c: 9,};var mulParsed = $parse('mul(a, add(b, c))');$scope.value = mulParsed($scope.context, $scope.locals);//得到值是33. 3 * (2 + 9) $parse最常见的用法即解析一个字符串变量到scope上. angular 的模版页中变量的解析也是由$parse提供的.如果$parse解析出来的是一个对象属性(a.b || [a]), 那么返回的函数会提供一个assign方法, assign是对这个对象设置值的方法. 12345678910$scope.a = { b: { c: 5, },};var cGetter = $parse('a[&quot;b&quot;].c');var cSetter = cGetter.assign;console.log(cGetter($scope)); //5cSetter($scope, 10);console.log(cGetter($scope)); //10 不过实际使用的时候, $eval比$parse更常用一些, 可以不需要注入直接由$scope调用. $eval$eval的源码也是十分简单的. 123$eval: function(expr, locals) { return $parse(expr)(this, locals);}, 使用起来和$parse差不多, 省略了一步生成解释函数的过程. 下面看看什么情况下来使用$eval. 12345678910&lt;div my-app&gt; &lt;div ng-if='!loading'&gt; &lt;div other-directive&gt; &lt;div content-directive content-text='text'&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;//myApp {scope.text = 'eval内容'}//otherDirective {scope: true,}//contentDirective {scope: {contentText: '='}} 在以上代码中, 最内层的指令contentDirective可以获取到myApp中 text 的值, 但是如果在contentDirective里面对contentText修改, myApp是拿不到改变以后的值的. 这是因为otherDirective的scope: true是对scope进行原型继承, 在当前取不到值可以顺原型链继续读取, 可是修改值的时候是不能设置原型链上的值的. 解决办法可以是传入一个对象, 那么修改只是修改这个对象的属性, 所以可以读取到值, 这也是推荐的做法. 但是如果你确实不想传入对象, 那么就可以使用$eval来解决这个问题. 123456789101112131415161718192021&lt;div my-app&gt; &lt;div ng-if=&quot;!loading&quot;&gt; &lt;div other-directive&gt; &lt;div content-directive content-text=&quot;text&quot; scope-level=&quot;3&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;//contentDirectivescope: {scopeLevel: '=', contentText: '='},link: function($scope, $element, attrs, ctrls) { $scope.scopeLevel = $scope.scopeLevel || 1; var $parent = $scope; var levelInt = parseInt($scope.scopeLevel); while(levelInt &gt; 0 &amp;&amp; levelInt != Infinity){ $parent = $parent.$parent; levelInt--; } $scope.contentText = 'newContentText'; //设置值, 如果不使用$eval, 当attrs['contentText']为多层属性时不能设置值. $parent.$eval(attrs['contentText'] + ' = contentText', $scope);} $watch$scope.$watch(key, func, isDeep)可以监听一个$scope上给定key的值的变化, 如果有变化则调用 func, 返回值是一个注册函数, 再次执行注册函数可以取消该监听. 第三个参数为是否深度比较, 不建议设置为 true, 太占用性能. $observe12345678910111213$observe: function(key, fn) { var attrs = this, $$observers = (attrs.$$observers || (attrs.$$observers = {})), listeners = ($$observers[key] || ($$observers[key] = [])); listeners.push(fn); $rootScope.$evalAsync(function() { if (!listeners.$$inter) { // no one registered attribute interpolation function, so lets call it manually fn(attrs[key]); } }); return fn;} 如果说$watch基本可以满足传值到指令里面再次改变以后的事件触发, 那么attrs.$observe(key, func)则是监听属性的变化以及触发事件. 这两个的区别是: 当你的传值方法为key=&quot;{{someone}}&quot;时, 使用$scope.$watch(attrs.key)是无效的, 因为{{}}这种值无法解析, 这时候就需要用attrs.$observe, 在源码里面可以看到调用的是$evalAsync这个方法, 这个方法和$eval的区别是该方法为延迟执行, 但是会在本轮$digest循环期间执行, 在$digest里面可以看到是在所有$scope上的watch执行完成以后调用, 所以能够监听到括号表达式的值. 附$digest源码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113$digest: function() { var watch, value, last, fn, get, watchers, length, dirty, ttl = TTL, next, current, target = this, watchLog = [], logIdx, logMsg, asyncTask; beginPhase('$digest'); // Check for changes to browser url that happened in sync before the call to $digest $browser.$$checkUrlChange(); if (this === $rootScope &amp;&amp; applyAsyncId !== null) { // If this is the root scope, and $applyAsync has scheduled a deferred $apply(), then // cancel the scheduled $apply and flush the queue of expressions to be evaluated. $browser.defer.cancel(applyAsyncId); flushApplyAsync(); } lastDirtyWatch = null; do { // &quot;while dirty&quot; loop dirty = false; current = target; while (asyncQueue.length) { try { asyncTask = asyncQueue.shift(); asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals); } catch (e) { $exceptionHandler(e); } lastDirtyWatch = null; } traverseScopesLoop: do { // &quot;traverse the scopes&quot; loop if ((watchers = current.$$watchers)) { // process our watches length = watchers.length; while (length--) { try { watch = watchers[length]; // Most common watches are on primitives, in which case we can short // circuit it with === operator, only when === fails do we use .equals if (watch) { get = watch.get; if ((value = get(current)) !== (last = watch.last) &amp;&amp; !(watch.eq ? equals(value, last) : (typeof value === 'number' &amp;&amp; typeof last === 'number' &amp;&amp; isNaN(value) &amp;&amp; isNaN(last)))) { dirty = true; lastDirtyWatch = watch; watch.last = watch.eq ? copy(value, null) : value; fn = watch.fn; fn(value, ((last === initWatchVal) ? value : last), current); if (ttl &lt; 5) { logIdx = 4 - ttl; if (!watchLog[logIdx]) watchLog[logIdx] = []; watchLog[logIdx].push({ msg: isFunction(watch.exp) ? 'fn: ' + (watch.exp.name || watch.exp.toString()) : watch.exp, newVal: value, oldVal: last }); } } else if (watch === lastDirtyWatch) { // If the most recently dirty watcher is now clean, short circuit since the remaining watchers // have already been tested. dirty = false; break traverseScopesLoop; } } } catch (e) { $exceptionHandler(e); } } } // Insanity Warning: scope depth-first traversal // yes, this code is a bit crazy, but it works and we have tests to prove it! // this piece should be kept in sync with the traversal in $broadcast if (!(next = ((current.$$watchersCount &amp;&amp; current.$$childHead) || (current !== target &amp;&amp; current.$$nextSibling)))) { while (current !== target &amp;&amp; !(next = current.$$nextSibling)) { current = current.$parent; } } } while ((current = next)); // `break traverseScopesLoop;` takes us to here if ((dirty || asyncQueue.length) &amp;&amp; !(ttl--)) { clearPhase(); throw $rootScopeMinErr('infdig', '{0} $digest() iterations reached. Aborting!\\n' + 'Watchers fired in the last 5 iterations: {1}', TTL, watchLog); } } while (dirty || asyncQueue.length); clearPhase(); while (postDigestQueue.length) { try { postDigestQueue.shift()(); } catch (e) { $exceptionHandler(e); } }} $apply &amp; $digest$digset循环就是angular的核心循环了, angular就是在这个循环里面执行脏值检测, 更新scope和页面, 进行双向绑定和触发watch事件的. 那么如果我们需要在某些地方触发双向绑定和事件, 只需要进入这个循环就可以了. angular提供了几种进入$digset循环的方法. $apply$scope.$apply()会触发整个应用中的所有$scope上的$digset循环, 即刷新整个应用的双向绑定值等等. 因为执行的是全部, 所以频繁调用还是会导致性能问题, 所以有了下一个方法$digset $digset$scope.$digset()会触发当前scope和子scope中的$digset循环, 那么造成的问题是父节点不会刷新, 优点是对于性能有明显的改善. $evalAsync$scope.$evalAsync()有两种情况, 如果当前正在$digset循环中, 那么会添加到$digset循环尾部执行, 如果不在$digset循环中, 那么它可以触发新一轮的$digset循环. $timeout在没有$evalAsync之前, 在angular上下文之外触发$digset循环的方法比较常用的就是它, 基本等于setTimeoout, 在执行的最后会调用$apply触发$digset循环. $applyAsync也可以触发$digset循环, 和$apply有点区别, 定义一个延迟执行任务, 如果不存在applyAsyncId, 会调用$rootScope.$apply. 在$digset源码里面可以看见, 在$rootScope中才会触发定义的applyAsync方法, 如果你手动调用的是非$rootScope的$digset循环, 那么不会触发applyAsync里面定义的方法. 官方说明是方便$http在请求结束的时候合并$apply的调用, 实际项目里面使用到的情况还是$evalAsync比较常用一些.","link":"/2016/2016-11-14-angularjs-eval-watch/"},{"title":"angularjs 的一些小技巧和实现","text":"angular关于 angularangular 的实用和方便性就不说了, 说说要注意的一些地方. 尽量不要用{{}}`做绑定数据, 使用`ng-bind`. 原因是当浏览器卡的时候页面会显示出`{{item.name}}这样的代码(也可用ng-cloak). 对于在 onchange 触发的 input, 可以使用ng-model-options=&quot;{ debounce: 500 }&quot;使事件触发不会那么频繁, 提高性能(在用于给比较大 table 做 filter 的时候性能提升明显). 少用$watch. 有一种说法是超过 1000 个 watcher 以后, 整个系统的卡顿就会特别明显, 多使用自定义事件回调机制, 对于指令的作用和功能也更清晰. 同 3 类似, 对于那些只有展示一次作用, 不会再次改变的数据, 使用 oncebind 命令::, 如ng-bind=&quot;::item.name&quot;. 在各种 table 和 repeat 里面比较常用. 有个小技巧是: 如果你的 repeat 里面的数据不会变化, 把 repeat 的传入值也改成一次性的ng-repeat=&quot;item in ::dataList&quot;. 用好$compile. $compile是 angular 暴露出的内部转换 html 模版到编译函数的功能, 虽然各种ng-if ng-show ng-class已经为动态展示元素提供了很好的帮助, 但是对于一些复杂的页面元素(比如根据后台条件生成不同的验证指令控件), 直接写一个 htmlHelperServer 方法生成正确的 html, 然后使用$element.append($html)), $compile($element.contents())($scope)加入到当前指令中. service 的使用. 如果你的指令应该传入一个 tree 形数据, 而后台拿到的是 list, 那么这个指令所在的模块的 service 里应该有写好的如何把 list 转换成有效的 tree 数据方法. 这样其他人使用这个指令时可以注入这个 service, 使用已有的转换方法. scope angular 有个快速获取某个元素所在 scope 的方法:$(ele).scope(), 结合$.fn.closest可以很方便的拿到上级 scope. 但是并不推荐在代码里使用, 会打乱层级关系和造成代码混乱. 正确的方式是依赖上级指令require: '^parent', 通过link的ctrls参数拿到上级的相关方法. $scope.$apply()有时候在指令里面不得不使用jquery或者其他方法改变绑定到 angular 里的对象属性, 这时候通常会使用$scope.$apply()来把改变同步到界面上. 存在问题是如果这个时候是处于$digest循环中, 那么apply会报错. 推荐做法是封装一个safeApply在rootScope上, 需要使用的地方使用$scope.$root.$safeApply();. 12345$rootScope.$safeApply = function () { if ($rootScope.$$phase != '$apply' &amp;&amp; $rootScope.$$phase != '$digest') { $rootScope.$apply(); }}; directive 指令可以分成两种类型: 容器指令和展示指令, 前者保存数据和提供操作函数以及界面的组合, 后者只做部分特殊的展示和提供回调. 数据应该跟随指令保存, 而不是controller. 普通指令应该全部支持A属性, 容器指令支持E属性且replace设置为true, 在写 html 的时候不能出现自定义的闭合标签, 因为部分浏览器对闭合标签支持不友好. 普通指令通过attribute的方式使用, 方便组合以及自定义样式. 特别是那些纯功能性不提供 dom 的指令, 使用transclude: true,replace: true,scope: true来做到低耦合. 对于组合式指令, 多个指令用于一个元素时, 可以设置这些指令的优先级, 加载顺序是由priority参数定义的. 还可以设置 terminal, 停止低于某个指令的优先级的其他指令运行. 对于这些指令, 都不应该有自己的 scope 作用域, 即只能设置scope: false或者不设置. 如果一个元素上多个指令都有自己的scope, 会报错. 指令的销毁. 在指令从界面上移除的时候(包括ng-if=false), 会触发$destroy事件, 在指令中设置$scope.$on('$destroy',func), 可以接收到此事件进行一些操作, 比如清除生成的watch, 释放$timeout, 清除jquery动态添加的全局元素等, 回收内存. 指令的事件广播. 只推荐在全局中使用广播, 因为指令可选择接收或不接收, 属于被动接收全局控制, 而且要定义好广播命名和规范的接收文档. 在容器指令中发送广播会影响全局代码的混乱. 如果需要主动发送全局事件, 请使用require和ctrls来调用相关父级指令函数. 指令的controller. 正常情况下应该只有容器指令和最外层的指令有controller, 里面的下级指令可以依赖该指令拿到外层的相关属性和方法. controllerAs是个很令人迷惑的属性, 简单点说就是把 as 的 name 绑定到 scope 上, 即在controller里面返回的 this 作为一个对象返回, 在scope[name]里面可以取到这个 this 对象. 还可以使用bindToController 选择需要的属性自动绑定到 this 上. 一般情况下controller都只定义一些方法, 供其他指令使用. 也可以做一些初始化的操作, 毕竟controller运行在 link 前面, 不过注意不能使用 dom, 这时候 dom 还没有加载到界面上. 父级调用下级的方法. 有时候父级作为容器组件, 下级是纯展示组件, 而且还有很多个. 那么父级上有个事件需要改变下级的状态, 怎么处理呢? 通常我们会在下级的 link 里面最后加上以下方法暴露出去所提供的方法.当然指令里面需要接收scope``initComplete: '=?', 父级在调用的时候需要写一个接收方法的回调并保存下级的方法, 在需要的时候调用. 这样就实现了展示组件和容器组件的解耦. 当然下级调用父级的就是很简单的 require 然后通过 ctrls 调用了. 123456if ($scope.initComplete) { var exports = { fun: $scope.fun, }; $scope.initComplete(exports, $scope, $element);} controller 尽量少使用独立的controller, 一般都是作为和指令关联的controller才需要用到. controller 不要用于构建界面, 只有指令才作为界面的元素. controller只定义方法. 系统中只需要少数几个controller, 一个是runController, 在最开始的入口执行, angular.module(appName, [...commonModules]).directive('myApp', myAppDirective.myApp).run(runCtrl);定义一些自定义的方法和初始化值, 比如我们的highChart的配置就是写在这里. 上面说的$safeApply也是在这里定义的. 还有几个controller是在路由切换的时候需要提供不同的方法加载路由. controller作为指令的定义是一个字符串的时候, 只是把那个方法里的内容移到以那个字符串命名的controller里面, 在指令的 link 里面第四个参数能拿到那个controller, 其他没有什么区别. provider在系统里只推荐使用两种provider, constant和service. constantconstant定义常量, 比如各种服务地址, 通过生成一个config对象, 供全局使用. serviceservice完全可替代factory, 当返回值是对象时, 和factory没有区别(原理是通过 new 调用的方法, 无返回值时可以设定this). 由于是单例模式, 也可以当作全局变量使用, 如注册一个可改变的configService到全局, 则全局可读写并动态配置.把所有与后台接口交互的方法均定义到service里面, service提供的方法应该与后台同步, 命名相同, 这样就保证后台方法修改的时候, 前端只用修改一个service里的调用. 所有的请求应该通过一个自定义的 ajax 发出去, 即在service里只有参数和配置, 没有 url 和解析. 123456789101112131415161718192021(function (define) { 'use strict'; define([], function () { var demoService = function ($q, ajaxService) { var functionName = function (content, info, onComplete) { var data = { CommandName: 'ClassName$FunctionName', params: { content: content, info: info, }, }; return ajaxService.post(data, onComplete); }; return { functionName: functionName, }; }; return ['$q', 'App.ajaxService', demoService]; });})(define); promise 和 onComplete为了兼容性和减少开发人员入门学习成本, 学习jquery提供两种方式的回调, 在有onComplete参数的时候, 调用onComplete, 同时返回promise对象, 可以在后面自由添加[then|catch]方法. 同时在ajaxService.post里面请求失败触发回调时, 也检测标准 http 错误(500)并记录日志到后台. decoratordecorator可以注入constant来改变service的行为, 不过目前没有碰到需要使用的情况, 按需使用即可. module使用require构建模块化的 angularJs 项目.在每个模块里声明自己的directive和service以及modName, 再在系统的总入口里面注册该模块, 这样每个 mod 都是独立的, 不会互相干扰. 在异步加载 mod 的时候也方便操作.区分模块是创建还是获取是根据第二个参数是否传入有关, 如果传入数组, 则表示是创建模块, 否则是根据模块名获取模块. 123456789//commonMod.js(function (define, angular) { 'use strict'; define(['common/configMod', 'common/commonService', 'common/commonDirective'], function (configMod, commonService, commonDirective) { var modName = 'App.commonMod'; angular.module(modName, [configMod]).service('App.commonService', commonService).directive('myDirective', commonDirective.myDirective); return modName; });})(define, angular);","link":"/2016/2016-12-20-angularjs-practice/"},{"title":"chrome扩展开发","text":"前言最近, 因为不可抗力的关系, google越来越难用了, 而且好不容易能连上, 反应也特别慢. 迫不得已只能用百度, 而百度的广告也是越来越恶心了, 搜个代码都能出现一堆广告. 既然是自己的浏览器, 那就自己想想办法来干掉百度吧. extensionchrome以及使用Chromium内核的浏览器, 都可以使用extension来增强浏览器功能. 如大名鼎鼎的Adblock Plus插件等. 插件原理是chrome提供一系列API来供用户自定义操作浏览器. manifestmanifest.json文件是所有扩展插件的起点, 里面给定了插件的权限, 功能, 运行时间, 依赖等. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//manifest.json{ &quot;manifest_version&quot;: 1, &quot;name&quot;: &quot;百度一下!&quot;, &quot;version&quot;: &quot;1.0.0.0&quot;, &quot;description&quot;: &quot;from zhoucong&quot;, &quot;icons&quot;: { &quot;16&quot;: &quot;icon3x72.png&quot;, &quot;48&quot;: &quot;icon3x72.png&quot;, &quot;128&quot;: &quot;icon3x72.png&quot; }, &quot;browser_action&quot;: { &quot;default_icon&quot;: &quot;icon3x72.png&quot;, &quot;default_title&quot;: &quot;全功能扩展～！&quot;, &quot;default_popup&quot;: &quot;popup.html&quot; }, &quot;options_page&quot;: &quot;options.html&quot;, &quot;background&quot;: { &quot;scripts&quot;: [&quot;js/lib_js/jquery-2.1.4.js&quot;,&quot;js/background.js&quot;] }, &quot;commands&quot; : { &quot;_execute_browser_action&quot;: { &quot;suggested_key&quot;:{ &quot;windows&quot;: &quot;Ctrl+Shift+S&quot;, &quot;mac&quot;: &quot;Command+Shift+S&quot;, &quot;chromeos&quot;: &quot;Ctrl+Shift+S&quot;, &quot;linux&quot;: &quot;Ctrl+Shift+S&quot; } } }, &quot;permissions&quot;: [ &quot;background&quot;, &quot;storage&quot;, &quot;bookmarks&quot;, &quot;nativeMessaging&quot;, &quot;tabs&quot;, &quot;contextMenus&quot;, &quot;activeTab&quot;, &quot;webRequest&quot;, &quot;webRequestBlocking&quot;, &quot;downloads&quot;, &quot;http://*/*&quot;, &quot;https://*/*&quot; ], &quot;content_security_policy&quot;: &quot;script-src 'self' 'unsafe-eval'; object-src 'self'&quot;, &quot;content_scripts&quot;: [{ &quot;all_frames&quot;: true, &quot;matches&quot;: [&quot;*://*.baidu.com/*&quot;], &quot;js&quot;: [&quot;js/baidu_background.js&quot;], &quot;run_at&quot;: &quot;document_end&quot; }], &quot;web_accessible_resources&quot;: [&quot;js/lib_js/jquery-2.1.4.js&quot;, &quot;js/lib_js/jquery-custom.js&quot;]} browser_action定义了图标图片, 提示, 以及点击弹出的html文件.options_page定义的是在chrome://extensions/中点击选项的打开页, 一般用作插件用户自定义配置设置.background定义的是在插件在后台运行时需要的js.commands定义了快捷键.permissions表示插件所需权限, 会在安装插件时提示用户所需权限.content_scripts定义了匹配到相应页面时, 运行的js文件.web_accessible_resources定义的是在content_scripts中可以请求的js文件. baidu_background接下来创建baidu_background.js. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//这是个必要的函数, 用于将函数注入到页面function addscript(prefix, f, suffix) { var script = document.createElement(&quot;script&quot;); script.type = &quot;text/javascript&quot;; script.innerHTML = prefix + eval(f) + suffix; document.head.appendChild(script);}//主要函数function killAdsFunction() { if (!window.adcount) { //初始化 window.adcount = 0; window.killAds = []; } console.log('----------------kill baidu ads--------------------'); var $wrapper_wrapper = $('#wrapper_wrapper'); var $content_left = $('#content_left'); var ads = $content_left.children('div:has(a:contains(广告))'); window.adcount += ads.length; window._is_my_remove = true; ads.remove(); window._is_my_remove = false; console.log('页面加载完成时干掉了: ' + window.adcount + ' 个广告'); var pb = function (e) { if (window._is_my_remove == true) { return; } var ads = []; if ($(e.target).closest('#wrapper_wrapper').length &gt; 0) { console.log('屏蔽广告插件无刷新版本killAdsFunction启动!!!'); $content_left = $('#content_left'); window._is_my_remove = true; ads = $content_left.children('div:has(span:contains(广告):not(:has(*)))'); if(ads.length &gt; 0){ window.adcount += ads.length; ads.remove(); window.killAds = $.merge(window.killAds, ads); console.log('本次干掉: ' + ads.length + ' 个广告',ads); console.log('总共干掉了: ' + window.adcount + ' 个广告'); } window._is_my_remove = false; } }; $wrapper_wrapper.on('DOMNodeInserted DOMSubtreeModified', pb);}//注入页面addscript(&quot;(&quot;, killAdsFunction, &quot;)();&quot;); 运行在chrome://extensions/中点击加载已解压的扩展程序, 选中刚刚创建的文件夹, 即可看见扩展程序了. 加入插件前 加入插件后 后记chrome插件功能远远不止这么点功能, 更强大的还可以和windows程序通信, 在background.js中, 可以拦截网络请求, 和windows程序通信, 调用迅雷下载相关资源. 可以参考git.","link":"/2017/2017-01-05-chrome-extensions-start/"},{"title":"三大数据库的split函数","text":"前言在执行sql查询传参的时候, 为了防止sql注入, 一般都会使用参数化查询. 而例外的是in, 因为它是多参数, 所以一般都是在后台代码中拼好用逗号分割的字符串以后, 再直接使用字符串传入sql解释器. 这样一来, sql注入便是有可能成功的了, 而且防止sql注入的代码需要在后台完成. 为了解决这个问题, 我们只需要在sql中提供自定义函数拆分字符串即可. sqlserversqlserver应该算是最简单的了, 函数可以返回临时表, 查询起来也够简单. 12345678910111213141516171819202122232425262728293031323334CREATE FUNCTION [dbo].[f_Split] ( @str NVARCHAR(MAX) , @split_char NVARCHAR(10) )RETURNS @table TABLE ( value NVARCHAR(MAX) )AS BEGIN IF @str IS NULL OR @split_char IS NULL OR LEN(@str) = 0 OR LEN(@split_char) = 0 RETURN DECLARE @index INT SET @index = CHARINDEX(@split_char, @str) WHILE @index &gt; 0 BEGIN INSERT @table VALUES ( LEFT(@str, @index - 1) ) SET @str = RIGHT(@str, LEN(@str) - @index) SET @index = CHARINDEX(@split_char, @str) END INSERT @table VALUES ( @str ) RETURN END-- 使用SELECT * FROM dbo.f_Split('1,2,3,4',',')SELECT * FROM dbo.temp t0WHERE t0.ID IN ( SELECT value FROM dbo.f_Split('1,2,3,4',',')) oracleoracle也简单, 在使用的时候用table函数调用即可. 1234567891011121314151617181920212223242526272829CREATE OR REPLACE TYPE f_split_type IS TABLE OF VARCHAR2 (4000)CREATE OR REPLACE FUNCTION f_split(str VARCHAR2, split_char VARCHAR2 := ',')RETURN f_split_type PIPELINED IS v_i INTEGER; v_str_value VARCHAR2(500); v_str VARCHAR2(4000) := str;BEGIN LOOP v_i := INSTR(v_str, split_char); EXIT WHEN v_i = 0; v_str_value := SUBSTR(v_str, 1, v_i - 1); v_str := SUBSTR(v_str, v_i + 1); PIPE ROW(v_str_value); END LOOP; PIPE ROW(v_str); RETURN;END f_split;-- 使用SELECT t.COLUMN_VALUE FROM TABLE(f_split('1,2,3,4,5','2')) tSELECT * FROM temp t0WHERE t0.ID IN ( SELECT COLUMN_VALUE FROM TABLE(f_Split('1,2,3,4',','))) mysqlmysql是比较麻烦的了, 不提供临时表可用, 而且函数不能返回结果表. 只能用一种简单的办法, 创建一个单独用作保存结果的表, 然后联合查询. 这里设置的清除数据时间是一小时, 即自动清除一小时之前的临时数据. 12345678910111213141516171819202122232425262728293031323334353637383940414243-- 临时表CREATE TABLE `split_temp_table` ( `id` int(11) NOT NULL AUTO_INCREMENT, `mainId` varchar(50) DEFAULT NULL, `value` varchar(100) DEFAULT NULL, `createTime` datetime DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8-- 函数CREATE FUNCTION `f_split` (str VARCHAR (2000),split_char VARCHAR (10)) RETURNS VARCHAR (50) CHARSET utf8BEGIN DECLARE uid VARCHAR (50) ; DECLARE i INT; DECLARE now_time DATETIME; SET now_time = NOW(); DELETE FROM `split_temp_table` WHERE createTime &lt; SUBDATE(now_time,INTERVAL 1 HOUR); IF (str IS NULL OR LENGTH(str) = 0 OR split_char IS NULL OR LENGTH(split_char) = 0) THEN RETURN NULL; END IF; SET uid = UUID() ; SET i = LOCATE(split_char,str); WHILE i &gt; 0 DO INSERT INTO split_temp_table(mainId, `value`, createTime) VALUES(uid, LEFT(str,i - 1), now_time); SET str = RIGHT(str,LENGTH(str) - i); SET i = LOCATE(split_char,str); END WHILE; INSERT INTO split_temp_table(mainId, `value`, createTime) VALUES(uid, str, now_time); RETURN uid ;END $$-- 使用SELECT f_split('1,2,3',',') INTO @uid;SELECT * FROM temp t0WHERE t0.ID IN ( SELECT t1.`value` FROM split_temp_table t1 WHERE t1.`mainId` = @uid) 这三个函数完成以后, 在查询的时候就可以直接使用参数化传入带逗号分割的字符串了, 不需要考虑sql注入和sql拼接了.","link":"/2017/2017-02-20-sql-split-string-by-char/"},{"title":"sublime插件开发","text":"在写前端代码的时候, vs虽然有比较完美的智能提示和格式化, 但是字体太大和占用内存太大, 而且比起纯代码编辑器还是卡了一点, 所以一般还是习惯使用sublime来写html等前端代码. 但是最近有一点用得很不舒服的就是代码格式化. sublime是没有自己的代码格式化的, 需要格式化都需要使用插件来完成, 而我目前使用的有HTML-CSS-JS Prettify, 格式化出来的效果还是比较好的, 唯一有一点不舒服的就是会有一点点卡顿的感觉, 在js文件比较大的时候更明显. 而有时候在复制一些代码时, 特别是使用ESLint格式化的代码, 在粘贴到sublime里面的时候, 由于ESLint默认的缩进是2行, 而项目组里面的代码都是4行缩进的, 贴进来以后就显得很不协调, 即使是用带格式的粘贴ctrl + shift + v也不能解决这个问题, 只能默认缩进到当前行, 但是里面的缩进还是2行. 而每次粘贴完成代码以后使用一次格式化又感觉有点卡和不爽, 所以想自己写个小插件来解决这个问题. 首先新建一个plugins, 点击Tool -&gt; New Plugin...会出现一个默认的Hello World文件, 能发现它的语法是python. 然后用ctrl + ~打开控制台, 保存该文件到Packages下demo目录, 文件名为demo.py. 保存的时候就能看到控制台出现提示, reloading plugin ..., 表示插件读取到了. 既然是python, 那么测试一下, 发现不支持print 'a'这种语法可知python版本为3.x. 运行方式, 在.py文件中, 主函数名为xAxBxCommand, 那么在控制台中输入view.run_command('x_ax_bx')即可运行该插件. 剩下的就是开发python了. 打开vs, 建个python工程, 写好转换函数, 贴进来就可以使用了. 首先是获取剪切板内容, 查API可得使用函数sublime.get_clipboard()即可获取当前剪切板内容. 剩下就是简单的修改字符串函数了. 1clipboardStr = sublime.get_clipboard() 首先是把\\t转换成空格, clipboardStr = clipboardStr.expandtabs(4).然后是把行分割成数组, 这里有个问题是window中, 行结尾符可能是\\r\\n也可能是\\n, 这里处理方法是如果有\\r\\n即使用\\r\\n做分隔符. 1234split_symbol = '\\n'if clipboardStr.find('\\r\\n') &gt; -1: split_symbol = '\\r\\n's_list = clipboardStr.split(split_symbol) 如果当前剪切板只有一行, 那么就直接调用paste_and_indent(ctrl + shift + v)粘贴即可. 12if len(s_list) == 1: self.view.run_command('paste_and_indent') 如果超过一行, 那么先将每行都往前缩进最小的空格数量, 即去掉多余的空格, 按本来的缩进排列, 这里存在一个问题是, 可能在复制的时候第一行是没有复制到空格而是直接复制得代码, 所以需要特殊处理一下.再计算每行的最小前置空格差, 如果最小相差为2, 那么说明这段代码的原始tab占空格为2个, 否则为4个. 如果tab占空格为2的话, 那么将每行的前置空格数量翻倍即可. 12345678910111213141516171819202122232425262728293031preIndent = 0if len(s_list) == 1: self.view.run_command('paste_and_indent')else: preIndent = self.getLeftSpace(s_list[0]) if preIndent == 0: preIndent = 1000 leftSpaceList = [0] for s in s_list[1:]: leftSpace = self.getLeftSpace(s) leftSpaceList.append(leftSpace) preIndent = leftSpace if leftSpace &lt; preIndent else preIndent s_list[0] = s_list[0].lstrip() minPreIndentSpace = 1000 leftSpaceList.sort() for i in range(1, len(leftSpaceList)): leftSpaceSplit = leftSpaceList[i] - leftSpaceList[i-1] if leftSpaceSplit &gt; 0 and leftSpaceSplit &lt; minPreIndentSpace: minPreIndentSpace = leftSpaceSplit if preIndent &gt; 0: for index in range(1, len(s_list)): s = s_list[index] if self.getLeftSpace(s) &gt;= preIndent and len(s.strip()) &gt; 0: s_list[index] = s[preIndent:] if minPreIndentSpace == 2: for index in range(0, len(s_list)): if self.getLeftSpace(s_list[index]) &gt;= minPreIndentSpace: s_list[index] = s_list[index].replace(' ', ' ') clipboardStr = split_symbol.join(s_list)def getLeftSpace(self, s): return len(s) - len(s.lstrip()) 然后将值设置到剪切板中, 调用paste_and_indent即可. 12sublime.set_clipboard(clipboardStr)self.view.run_command('paste_and_indent') 然后去设置一个快捷键, 建立一个Default (Windows).sublime-keymap文件, 内容为: 123[ { &quot;keys&quot;: [&quot;ctrl+shift+v&quot;], &quot;command&quot;: &quot;paste_with_tab&quot; }] 这里直接覆盖了原始的ctrl + shift + v命令. command即PasteWithTabCommand的驼峰转换小写形式. 再加一个菜单文件Main.sublime-menu, 内容: 1234567891011121314[ { &quot;id&quot;: &quot;edit&quot;, &quot;children&quot;: [ { &quot;caption&quot;: &quot;-&quot;, &quot;id&quot;: &quot;clipboard&quot; }, { &quot;caption&quot;: &quot;带缩进的粘贴&quot;, &quot;command&quot;: &quot;paste_with_tab&quot; }, ] }] 所有代码见git","link":"/2017/2017-03-06-sublime-plugins/"},{"title":"使用css3的flex布局和rem大小单位","text":"flex在以前做框架布局的时候, 一般都是使外层元素设置height:100%;width:100%;, 使用外层元素设置padding, 内层也可以使用height:100%;width:100%;来布局(元素需要为border-box). 对于那些固定的元素, 可以使用calc(100% - npx)这种方式来动态计算布局. 而在css3中, 出现了一种新的布局模型flex, 相关语法可以看这里, 可以比calc更优雅和简洁的实现动态布局, 不过对于IE系列只有IE 10+才支持, IE 9便只能使用calc或其他方式了. flex可以做到的几种布局 : 对某个方向自动填充, 如果超过则压缩元素, 可以设置指定元素需要压缩和比例. 如果不超过可以自动拉伸元素, 可设置指定元素拉伸和比例. 如果元素全为固定大小, 可以设置如果不填满时的填充方式, 有flex-start | flex-end | center | space-between | space-around五种可选, 分别是从起点开始, 终点开始, 居中, 两端对齐且每项间隔相等, 每项两侧间距相等. 设置在垂直轴上的布局方式, 常见的垂直居中可以很简单的实现. 如果设置为wrap即换行模式, 可以设置超过一行的情况下的行的布局. 可以对子项单独设置排序(order), 放大比例(flex-grow), 缩小比例(flex-shrink), 在计算拉伸时所占实际大小(flex-basis), 单独的垂直轴布局方式(align-self) 一般情况下, 如两端固定, 中间可拉伸的布局代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;demo&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; html, body { width: 100%; height: 100%; padding: 0; margin: 0; } * { box-sizing: border-box; } .flex-row{ height: 300px; background-color: #ccc; display: flex; flex-flow: row nowrap; } .start{ flex: 0 1 300px; background-color: yellow; } .end{ flex: 0 1 150px; background-color: blue; } .wrapper{ flex: 1 0 auto; display: flex; align-items: center; justify-content: center; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;flex-row&quot;&gt; &lt;div class=&quot;start&quot;&gt;开始&lt;/div&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;wrapper-center-content&quot;&gt;居中的中间&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;end&quot;&gt;结束&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果图 通过设置flex-direction属性, 可以设置元素是横向排列还是纵向排列, 从而可以构建出各种动态嵌套布局, 在修改相关元素大小的时候, 也不会影响到整体布局, 不用像之前写calc一样修改一点以后再去计算每个元素大小, 全交给浏览器自动计算, 省事方便很多. rem再看看rem单位, 之前出现的em单位是将字体大小与容器大小相匹配的单位, 即容器可以跟着字体大小动态变化, 不会出现字体比容器大的情况. 但是存在的问题是在写每个div的大小时, 需要知道当前em的比例, 即文字大小. 而rem单位出现便解决了这个问题, rem表示root-em, 即根节点的字体大小. 只需要设置html的font-size, 其他元素则都设置为1rem即可表示html的font-size大小, 在动态改变字体时, 也只需要修改html的font-size即可, 不会出现以前em的修改多处的问题. vh以前如果要设置一个元素高度是浏览器页面大小, 只能在外层通过height:100%;一层层传到内层元素, 或者使用js设置ele.style.height = window.innerHeight. 这样会很不方便, 而vh可以很简单的实现这个需求. 100vh == window.innerHeight. vwvh是高度单位, 那么vw则是宽度单位了, 表示100%的屏幕可见宽度. 在宽度自适应布局中, 比较简单的做法就可以用到vw了. 再结合flex布局, 可以说是非常强大的了. 123456.left-menu{ width: 25vw;}.main{ width: 75vw;} 再比如, 图片不能超过页面大小. 1234.max-img{ max-height: 90vh; max-width: 90vw;} vmvm表示的是vmin和vmax, 能想到要用到的地方就是做一个正方形的头部图片了. 1234.header-img{ height : 100vmin; width : 100vmin;} 这几个属性, 除了flex, 其他都支持IE9+, 而flex支持IE10+, 使用到的情况还是比较多的, 熟悉多用为好.","link":"/2017/2017-03-15-css3-flex-rem/"},{"title":".Net正则平衡组使用","text":"在.Net中, 正则表达式匹配支持两种高级语法: 匹配到的指定组名(?&lt;Group&gt;...) 根据组名的几种操作方式(?&lt;-Group&gt;), (?(Group)yes|no) 指定组名用?&lt;Group&gt;或?'Group'两种语法, 都可以为匹配到的组命名. 1234567var reg = new Regex(&quot;name:(?'groupName'[a-zA-Z0-9_-]+)&quot;);//var reg = new Regex(&quot;name:(?&lt;groupName&gt;[a-zA-Z0-9_-]+)&quot;);var matches = reg.Matches(&quot;name:test1,name:test2&quot;);foreach (Match m in matches){ var name = m.Groups[&quot;groupName&quot;].Value;} 组堆栈在使用?&lt;Group&gt;语法时, .net会将匹配到的内容压入堆栈stack. 然后在之后的匹配中, 可以使用语法?&lt;-Group&gt;从堆栈顶部弹出名字为&lt;Group&gt;的命名组, 如果堆栈为空, 那么该组匹配失败. 123456var reg = new Regex(&quot;name:(?&lt;nameMatch&gt;(?'stack'{[^{}]+)(?'-stack'}))&quot;);var matches = reg.Matches(&quot;name:{abc}&quot;);foreach (Match m in matches){ var name = m.Groups[&quot;nameMatch&quot;].Value;//{abc}} (?(Group)yes|no)的意义是, 如果堆栈上还存在名字为Group的组内容是, 执行yes语句, 否则执行no语句. 这时候可以使用(?!)零宽负向先行断言, 由于没有后缀表达式, 试图匹配总是失败. 即如果还存在Group时, 直接失败. 这几种语法结合起来, 就可以构造递归匹配的方法了. 如匹配类json格式字符串{l:{l1:{l2:3}}}. 1234567var reg = new Regex(@&quot;\\{(?&lt;match&gt;.+)\\}&quot;);//匹配到内容 : &quot;l:{l1:{l2:3}}&quot;//存在问题, 如果字符串为 &quot;{l:{ {l1:{l2:3}}}&quot; 也能匹配到全部var reg = new Regex(@&quot;\\{(?&lt;match&gt;(?&gt;[^{}]+|(?&lt;stack&gt;\\{(?!\\{))|(?&lt;-stack&gt;\\}))*(?(stack)(?!)))\\}&quot;);// {l:{l1:{l2:3}}} =&gt; l:{l1:{l2:3}}// {l:{ {l1:{l2:3}}} =&gt; l1:{l2:3}// {l:{ {l1:{ {l2:3}}} =&gt; l2:3 解释: 找到第一个{开始, 命名为match匹配组, 使用(?&gt;)非回溯(又名贪婪)匹配法则和固化分组进行内容匹配(对性能好), 匹配到 : 所有不是{}符号的内容[^{}]+ 或者如果是{, 而且后面不为{的内容则压入stack, 如果是}, 则弹出stack. 一直匹配到最后(贪婪模式), 如果最后还有stack, 则匹配失败({}数量不正确的情况不会匹配到). 这种语法的帮助在于可以递归匹配内容, 而且判断内容是否正确. 比如做SQL动态(0 嵌套)解析, 即可使用正则平衡组匹配. 1234567891011121314151617181920212223242526\\{\\? #匹配括号开始 -- 有一个括号和问号 (?&lt;DynamicClause&gt; #分组别名DynamicClause (?&gt; #非回溯(也称为 贪婪 )子表达式。 即在贪婪条件下匹配过去满足条件的, #如果碰见后面不满足的,则不会退回字符再查找 #用(?&gt;…)实现固化分组(成功匹配后，回溯时不会考虑这个匹配的字符) #!正常情况则是贪婪匹配,如果碰见不满足的可以退回字符再次查找满足的 [^\\{\\}]+ #除了{}的字符串 | #或者 \\{\\?(?&lt;Clause&gt;) #{[0-1个问号]push字符串到Clause -- 括号,可能有个问号,然后把Clause放进去 #命名捕获组,遇到正括弧Clause计数加1 | #或者 \\}(?&lt;-Clause&gt;) #}pop字符串Clause -- 反括号,然后把Clause弹出 #狭义平衡组,遇到闭括弧Clause计数减1 )* #0-n个这种字符串 (?(Clause)(?!)) #如果还有Clause匹配失败 ) #分组结束\\} #匹配括号结束//使用语法select * from tablewhere row = #row# and IsDel = 0 {? and a = #AValue#} {? and ({? b like '%' + #input# + '%'} {? or c = #input#})}","link":"/2017/2017-04-28-regex-group-match/"},{"title":"使用docker建立redis集群提供系统缓存","text":"最近做了系统的权限以及动态权限sql和配置库, 为了提升性能, 都做到了缓存里面, 缓存方法是, 当更新内容时同步写入锁清空缓存, 读取数据时使用可升级读取锁来读取缓存, 如果缓存为空时候升级写入锁读取数据库并写入缓存. 这样在单服务器上是比较好的读写策略了, 但是在多台服务器上却不能这样使用, 而需要使用其他的服务器来提供订阅更新等机制. 目前使用了redis. docker为了redis的高可用, 需要创建redis集群, 这里选择建立在多个docker环境中. 首先安装docker. 123sudo apt-get install curl //安装curlcurl -sSL https://get.docker.com/ | sh //获取最近版本dockerdocker run hello-world //安装完成以后测试是否成功 Dockerfile创建Dockerfile文件. 123456789101112131415// /usr/local/docker-files/DockerfileFROM redis:4.0.1MAINTAINER zhoucongENV REDIS_HOME /usr/localRUN mkdir $REDIS_HOME/confWORKDIR $REDIS_HOME/conf## 创建一个redis.conf文件，打开集群相关配置，默认端口不写的话为6379RUN echo &quot;cluster-enabled yes&quot; &gt; redis.confRUN echo &quot;cluster-config-file redis-nodes.conf&quot; &gt;&gt; redis.conf## 初始化容器时启动redis实例CMD [&quot;redis-server&quot;,&quot;/usr/local/conf/redis.conf&quot;] redis-container根据Dockerfile创建容器. 1docker build -t zhoucong/redis-test . 下载完成以后, 在/usr/local/redis/conf/下分别建立6501-65066 个文件夹, 因为redis集群至少需要 3 台主从机. 在每个文件夹下建立配置文件. 123cluster-enabled yescluster-config-file redis-nodes.confport 6501 //port(n) start docker启动这些 redis 节点 123456docker run -d --name redis-m-01 -v /usr/local/redis/conf/6501/:/usr/local/conf -p 6501:6501 -p 16501:16501 zhoucong/redis-testdocker run -d --name redis-m-02 -v /usr/local/redis/conf/6502/:/usr/local/conf -p 6502:6502 -p 16502:16502 zhoucong/redis-testdocker run -d --name redis-m-03 -v /usr/local/redis/conf/6503/:/usr/local/conf -p 6503:6503 -p 16503:16503 zhoucong/redis-testdocker run -d --name redis-c-04 -v /usr/local/redis/conf/6504/:/usr/local/conf -p 6504:6504 -p 16504:16504 zhoucong/redis-testdocker run -d --name redis-c-05 -v /usr/local/redis/conf/6505/:/usr/local/conf -p 6505:6505 -p 16505:16505 zhoucong/redis-testdocker run -d --name redis-c-06 -v /usr/local/redis/conf/6506/:/usr/local/conf -p 6506:6506 -p 16506:16506 zhoucong/redis-test 在主机中安装好redis后, 进入/redis/src/, 执行命令 redismake redis-cluster123456789sudo gem install redis //安装ruby的redis模块//创建集群ruby redis-trib.rb create --replicas 1 \\10.200.200.227:6501 10.200.200.227:6502 10.200.200.227:6503 \\10.200.200.227:6504 10.200.200.227:6505 10.200.200.227:6506//如果一直出现Waiting for the cluster to join.需要手动设置防火墙sudo ufw allow 6501-6506 16501-16506 connect redis-cluster本机连接docker里的redis 1234567//如果不使用-c, 会因为插槽不对报错/redis/src/redis-cli -c -h 10.200.200.227 -p 6501&gt; set test demo// -&gt; Redirected to slot [6918] located at 172.17.0.1:6502 ok 成功&gt; get test // -&gt; demo redis-lock到这里就成功了, 在后台使用相关库连接到redis, 然后就可以直接使用了. 缓存做法则改成在服务器中使用一级缓存, 全局使用redis来提供二级缓存, redis里不存在数据时去数据库获取数据并更新到redis中, 当更新数据时候先保存到数据库, 然后清空一级和二级缓存, 同时发布一个事件到redis中, 其他的服务器在订阅事件处理中清空一级缓存. 利用redis的SETNX和GETSET命令来锁住缓存对象, 防止并发时数据错误覆盖和死锁. 当然, 这只是一个简单的redis锁的实现, 而且不够强壮, 但是对于我们系统的使用已经足够, 而且系统也额外提供了清空和重新读取缓存的功能. 如果想要比较强壮的redis分布式锁, 可以参考这篇文章: 基于 Redis 的分布式锁到底安全吗（上）, 基于 Redis 的分布式锁到底安全吗（下）. 1234567891011//redis防止并发覆盖while(SETNX(cacheLock,now + 30s) == 0)//设置30s超时{ if(now &gt; GET(cacheLock) &amp;&amp; now &gt; GETSET(cacheLock,now + 30s)){ break;//成功拿到锁, 并给锁设置新值 }else{ Thread.sleep(500); }}//dosthDEL(cacheLock)","link":"/2017/2017-05-22-docker-redis/"},{"title":"ES6 import 模块导入分析","text":"ES6使js可以进行模块化开发了, 而模块化开发很容易的一个问题就是循环依赖. 而ES6的模块加载为引用形加载, 虽然对于函数这种可以动态找到值不会出现循环依赖的问题, 但是对于那些直接在外部定义的值还是会直接执行, 而这种情况就会出现值的循环依赖关系. 对于值循环依赖的这种情况一般都是可以避免的, 只要提取出来成为公共值即可. 而在提取时需要一个个文件跟踪import查看依赖, 太麻烦了, 所以为项目组提供一个import分析器来解决这个事情. 123456789101112131415161718192021222324252627282930313233343536public void Resolve(Dictionary&lt;string, JsFile&gt; dic){ if (this.ImportStatus != JsFileImportStatus.ImportNone) { this.ImportStatus = JsFileImportStatus.ImportComplete; return; } this.ImportStatus = JsFileImportStatus.Importing; foreach (var im in this.ImportStrings) { try { var tmpFile = GetJsFile(this.FilePath + im, dic, im); if (tmpFile.ImportStatus == JsFileImportStatus.ImportNone) {//刚刚拿到的新文件 //tmpFile.ImportStatus = JsFileImportStatus.Importing; this.Imports.Add(new ImportStruct(tmpFile, JsFileImportStatus.ImportNone)); } else if (tmpFile.ImportStatus == JsFileImportStatus.Importing) {//在前面正在导入中了 //tmpFile.ImportStatus = JsFileImportStatus.ImportComplete; this.Imports.Add(new ImportStruct(tmpFile, JsFileImportStatus.Importing)); } else if (tmpFile.ImportStatus == JsFileImportStatus.ImportComplete) {//之前已经导入完成了 this.Imports.Add(new ImportStruct(tmpFile, JsFileImportStatus.ImportComplete)); } tmpFile.Resolve(dic); } catch (Exception e) { continue; } } this.ImportStatus = JsFileImportStatus.ImportComplete;} 全部代码和软件在github中有, 使用效果如下: 左边的依赖树中, 绿色表示依赖关系正常, 红色表示依赖出现循环, 需要解决的地方. 右边显示的是依赖关系解析的json值, 如果需要可以拿去仔细分析依赖. 分析依赖原理基本和import原理一致, 按顺序依次加载, 如果遇到已经加载完成的, 则作为已经成功的, 显示绿色, 如果遇到新文件, 则标记为正在加载中, 如果遇到正在加载中的, 说明出现了循环依赖, 显示为红色, 需要处理该文件的加载问题.","link":"/2017/2017-05-31-es6-import-module-analyse/"},{"title":"SqlServer 开窗函数","text":"在mysql中, select a,count(b) from t这种语法是可以通过的, 选出来的a列是b中的第一个值. 但是在oracle和mssql中, 这种语法是不能用的, mssql会提示: 选择列表中的列'a'无效, 因为该列没有包含在聚合函数或GROUP BY 子句中. 简单点的解决办法是使用子查询: 1select a , (select count(b) from t) from t 但是这种sql写起来比较复杂, 而且查询性能不好, 这时候就可以使用开窗函数来解决这种问题了. 开窗函数语法有两种: 聚合开窗函数, 聚合函数(row) OVER (PARTITION BY) 排序开窗函数, 排序函数(row) OVER ([?PARTITION BY] ORDER BY) 1select a , count(b) over () from t 简单点可以理解为, 如果是聚合函数, 那么PARTITION BY即指定某些列, 聚合那些列数据相同的数据. 比如统计字段为月份, 那么就是每个月的值分别相加统计. 比起GROUP BY指定部分列统计时, 整个SELECT语句全在GROUP BY统计上灵活多了, 而且可以指定不同列来统计.对于几个排序函数ROW_NUMBER, RANK, DENSE_RANK, NTILE来说, 可以使用OVER (ORDER BY)字句, 即指定某些字段进行ORDER BY然后得出排名, 可以在一个查询中得到多种类型的排序, 而在ORDER BY前还可以使用PARTITION BY字句, 语法和效果与GROUP BY ORDER BY一样.","link":"/2017/2017-06-08-sqlserver-over-partition-by/"},{"title":"react 1 - jsx 和 组件","text":"react在看本篇之前, 应该有ES6语法基础. 如果没有, 推荐去学习阮一峰的 ES 6 入门. jsxreact与其他前端 MVVM 框架的最大区别之一应该就在于jsx与html-templete的区别了. 以前的框架都是基于已经存在的html做优化和操作, react却是舍弃了html, 用jsx来替代html的功能, 如果不了解的, 可以把jsx想象成高级版本的javascript代码, 所以比原始的html功能强大得多. 下面介绍jsx. 基本语法12345678const World = ({ children }) =&gt; ( &lt;div&gt; {children} {1 + 1} &lt;span&gt; World!&lt;/span&gt; &lt;/div&gt;);ReactDOM.render(&lt;World&gt;Hello&lt;/World&gt;, document.querySelector('#container')); 上面就是react创建一个组件的代码. jsx即在js代码里面写的类似html构建页面的代码, 语法类似xml, 所以叫jsx. 可以看到, ReactDOM.render函数的第一个参数就是jsx格式的内容, 而World函数的返回值也是一个jsx的内容.在react里面规定, 如果是大写字母开头的元素, 即作为自定义组件创建, 小写字母开头的元素, 即作为html原始控件创建. 所以World方法首字母必须大写.那么react到底怎么执行jsx的呢, 这看起来和原始的js以及html区别也太大了点, 下面我们就来看看jsx怎么执行的.首先, 浏览器是不可能认识jsx的, 那么就有一个叫babel的插件会把jsx编译成js代码, 和我们平常写的代码差不多, 来看看jsx的js版本吧. 123456'use strict';var World = function World(_ref) { var children = _ref.children; return React.createElement('div', null, children, 1 + 1, React.createElement('span', null, ' World!'));};ReactDOM.render(React.createElement(World, null, 'Hello'), document.querySelector('#container')); 以上代码就是最开始的例子, 由babel编译过后生成的js代码, 浏览器看到的也是这个代码. 从这个代码里我们来分析一下jsx的执行.首先创建一个World函数, 返回值是React.createElement创建的一个对象, 对象第五个参数又是一个对象, 不过大概根据内容能猜到是&lt;span&gt; World!&lt;/span&gt;这行代码. 而我们在jsx里写的{...}这种语法, 都被直接转换成了 js 加入到了参数列表中. 接下来我们看看React.createElement这个函数吧(删掉了一点&quot;development&quot; !== 'production'的代码, 不影响逻辑). 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253ReactElement.createElement = function (type, config, children) { var propName; // Reserved names are extracted var props = {}; var key = null; var ref = null; var self = null; var source = null; if (config != null) { if (hasValidRef(config)) { ref = config.ref; } if (hasValidKey(config)) { key = '' + config.key; } self = config.__self === undefined ? null : config.__self; source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object for (propName in config) { if (hasOwnProperty.call(config, propName) &amp;&amp; !RESERVED_PROPS.hasOwnProperty(propName)) { props[propName] = config[propName]; } } } // Children can be more than one argument, and those are transferred onto // the newly allocated props object. var childrenLength = arguments.length - 2; if (childrenLength === 1) { props.children = children; } else if (childrenLength &gt; 1) { var childArray = Array(childrenLength); for (var i = 0; i &lt; childrenLength; i++) { childArray[i] = arguments[i + 2]; } props.children = childArray; } // Resolve default props if (type &amp;&amp; type.defaultProps) { var defaultProps = type.defaultProps; for (propName in defaultProps) { if (props[propName] === undefined) { props[propName] = defaultProps[propName]; } } } return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);}; 可以看到, 这个函数接收三个参数, type,config,children, type就是span或者我们的World, config是传入的配置信息暂时不用管, children应该就是子节点, 在函数下部分可以看见, 判断如果childrenLength &gt; 1时, 将children拼成数组, 设置到 props 上.这样看来jsx其实很简单, 如果不想写jsx, 也可以手动调用React.createElement创建组件, 不过一般不需要这么做, 了解原理就好了. 组件声明方式无状态组件和有状态组件组件化是react的核心思想, react提供了两种组件声明方式, 上面使用的是函数式声明无状态组件, 还可以使用class extends React.Component方式声明有状态和生命周期的组件. 无状态组件是基于函数式思想, 同样的输入得到同样的输出, 而且react对无状态组件不会产生实例, 无实例化也就不需要分配多余的内存, 从而性能得到一定的提升. 原理上来说就是一直调用函数而已. 有状态组件可以使用react的生命周期函数, 实现一些高级功能. 123456789101112131415161718192021222324252627class World extends React.Component { render() { return ( &lt;div&gt; {this.props.children} &lt;span&gt; World!&lt;/span&gt; &lt;/div&gt; ); }}//jsx编译的代码var World = (function (_React$Component) { _inherits(World, _React$Component); function World() { _classCallCheck(this, World); return _possibleConstructorReturn(this, (World.__proto__ || Object.getPrototypeOf(World)).apply(this, arguments)); } _createClass(World, [ { key: 'render', value: function render() { return React.createElement('div', null, this.props.children, React.createElement('span', null, ' World!')); }, }, ]); return World;})(React.Component); 由编译后的代码可以看见, 在jsx的转换这块, 并没有什么区别. 组件的生命周期react有状态组件是有生命周期的, 从初始化到加载到销毁, 都可以设置相关函数. 下面来看看生命周期函数. getDefaultProps [=&gt; static defaultProps] getInitialState [=&gt; constructor(props, context)] componentWillMount render componentDidMount componentWillReceiveProps(nextProps) shouldComponentUpdate(nextProps, nextState) componentWillUpdate(nextProps, nextState) componentDidUpdate(prevProps, prevState) componentWillUnmount 除开getDefaultProps和getInitialState, react组件一共有 8 个生命周期函数可以使用. getDefaultProps和getInitialState是使用React.createClass()方式时的初始化方法, 在ES6``class类型的组件里面, 已经由static defaultProps和constructor(props, context)替代.这些函数的执行顺序依次是从上到下, 而且在componentWillUpdate和componentDidUpdate中间还会触发一次render函数. 网上有一张比较好的图说明它们的关系. 两种功能组件组件从功能性来说, 可以分为两种功能: 做页面展示和做逻辑交互. 所以我们写组件一般分成两种类型: 展示组件和容器组件. 展示组件 展示组件只做纯页面展示 可以包含子级的展示组件, 一般含有自定义样式 可以使用this.props.children来包含其他组件 一般不依赖其他组件和数据, 所有的数据都是由父级传入 可以有自己的状态变量, 不过一般都是为展示UI使用的变量 大多数都可以写成函数式组件, 除非有自己的状态变量 如果有自己的事件触发, 那么都会有相应的事件响应函数, 响应函数通常由父级传入. 展示组件所在文件夹为component 容器组件 容器组件一般包含很多个展示组件, 也可以有其他容器组件 容器组件一般很少有自定义样式, 基本都是用作包裹的div标签 容器组件负责从后台获取数据, 并交给展示组件负责展示 容器组件可以从展示组件的事件触发回调函数中获取数据并与后台交互 维持许多状态变量, 通常作为数据源 一般使用高阶组件生成(Redux.connect) 容器组件一般有自己的action和reducer 容器组件所在文件夹为container","link":"/2017/2017-08-01-react-day-1/"},{"title":"react 2 - route","text":"route可以说是现在的单页应用必备的功能了, 那么在react里, 官方也提供了一个路由库react-router, 也是唯一的一个路由库, 也提供了官方教程, 下面来看看如何使用吧. 注: 本文基于react-router 4.x先看一个简单的例子, 从这个例子来学习router的基本使用方法. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import React, { Component } from 'react';import ReactDOM from 'react-dom';import { BrowserRouter as Router, Route, HashRouter, Link, NavLink } from 'react-router-dom';var destination = document.querySelector('#container');class App extends Component { render() { return ( &lt;div&gt; &lt;h1&gt;Simple SPA&lt;/h1&gt; &lt;ul className='header'&gt; &lt;li&gt; &lt;NavLink exact to='/' activeClassName='active'&gt; Home &lt;/NavLink&gt; &lt;/li&gt; &lt;li&gt; &lt;NavLink to='/stuff' activeClassName='active'&gt; Stuff &lt;/NavLink&gt; &lt;/li&gt; &lt;li&gt; &lt;NavLink to='/contact' activeClassName='active'&gt; Contact &lt;/NavLink&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div className='content'&gt;{this.props.children}&lt;/div&gt; &lt;/div&gt; ); }}var Home = () =&gt; ( &lt;div&gt; &lt;h2&gt;HELLO&lt;/h2&gt; &lt;p&gt; Cras facilisis urna ornare ex volutpat, et convallis erat elementum. Ut aliquam, ipsum vitae gravida suscipit, metus dui bibendum est, eget rhoncus nibh metus nec massa. Maecenas hendrerit laoreet augue nec molestie. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. &lt;/p&gt; &lt;p&gt;Duis a turpis sed lacus dapibus elementum sed eu lectus.&lt;/p&gt; &lt;/div&gt;);var Contact = () =&gt; ( &lt;div&gt; &lt;h2&gt;GOT QUESTIONS?&lt;/h2&gt; &lt;p&gt; The easiest thing to do is post on our &lt;a href='http://forum.kirupa.com'&gt;forums&lt;/a&gt;. &lt;/p&gt; &lt;/div&gt;);var Stuff = () =&gt; ( &lt;div&gt; &lt;h2&gt;STUFF&lt;/h2&gt; &lt;p&gt;Mauris sem velit, vehicula eget sodales vitae, rhoncus eget sapien:&lt;/p&gt; &lt;ol&gt; &lt;li&gt;Nulla pulvinar diam&lt;/li&gt; &lt;li&gt;Facilisis bibendum&lt;/li&gt; &lt;li&gt;Vestibulum vulputate&lt;/li&gt; &lt;li&gt;Eget erat&lt;/li&gt; &lt;li&gt;Id porttitor&lt;/li&gt; &lt;/ol&gt; &lt;/div&gt;);ReactDOM.render( &lt;Router&gt; &lt;App&gt; &lt;Route exact path='/' component={Home} /&gt; &lt;Route path='/Contact' component={Contact} /&gt; &lt;Route path='/Stuff' component={Stuff} /&gt; &lt;/App&gt; &lt;/Router&gt;, destination,); NavLink即我们的a元素, 可以指向要跳转到的url, activeClassName可以指定一个在当前页面url和NavLink指向的url相匹配时候的class, 方便做一些样式高亮设计. Route组件则是路由实现的关键组件, 作用是当to属性里面的url匹配到当前页面, 则展示component中的组件. 在新版本中, Route已经变成随处可用的组件了, 可叠加可嵌套. 而且需要用到的组件都是从react-router-dom包里导出. 更多的例子可以去官网示例中查看. 在一般的项目中, 推荐将一级路由配置在页面最外层的组件里, 方便集中管理和维护, 如果内层组件有自己的router, 可以在组件内实现. 这是为了将子组件和主模块解耦. 如果项目需要权限管理, 推荐配置动态路由, 即路由数据由服务器根据个人权限获得. 而且可以根据需要, 将组件进行异步加载, 优化页面首次加载的速度. Redirect为重定向组件, 表示从path转向to, Switch组件即在下级的路由组件中只匹配一次, 由于匹配是按顺序进行, 所以我们的重定向到首页组件需要写在最后一位. exact属性表示精确匹配, 否则是模糊匹配. 12345678910111213141516&lt;div className='right-content'&gt; &lt;Switch&gt; {this.state.routeList.map((item, index) =&gt; { if (item.get('to')) { return &lt;Redirect key={index} path={item.get('url')} exact={item.get('exact')} to={item.get('to')} /&gt;; } else if (item.get('src')) { return &lt;Route key={index} path={item.get('url')} exact={item.get('exact')} render={() =&gt; &lt;AsyncComponent src={item.get('src')} /&gt;} /&gt;; } else { return null; } })} &lt;Route exact path='/' render={() =&gt; '欢迎来到首页'} /&gt; &lt;Redirect path='*' to='/' /&gt; &lt;/Switch&gt; {this.props.children}&lt;/div&gt; react-router原理hash-router本质上是基于浏览器提供的window.onhashchange事件, 只要改变location.hash, 就会触发该事件, 进行路由拦截和组件加载判断. 但是为了统一化, history模块也将hash-router封装成了和browser-router一样的使用方式和原理. browser-router本来浏览器提供了window.onpopstate来监听浏览器url改变事件, 但是通过js执行history.pushState({},title,url)或者history.replaceState时候, 却不会触发onpopstate事件, 所以只能自己实现一套拦截的体系. react使用的是history模块.在组件初始化的时候通过history.createBrowserHistory生成一个history对象, 该对象里面有一个事件监听列表和相关事件. 在Link组件中的a标签点击时, 使用preventDefault阻止页面跳转, 然后通过history.push/replace(to)进行跳转url. 在Router组件中的componentWillMount时, 会通过history.listen设置监听, 如果url有变化则通过setState进行修改. 而在使用Redux和PureComponent的情况下, setState不会引起下级组件的更新, 那么在ConnectedRouter中的componentWillMount中, 也添加了history.listen来监听url的更改, 同时通过store.dispatch({type: LOCATION_CHANGE,payload: location})来发送action到reducer中, 这就是为什么引入immutable时, 需要手动设置routerReducer在action.type === LOCATION_CHANGE时候的原因了.","link":"/2017/2017-08-02-react-day-2/"},{"title":"react 3 - redux","text":"前言 “如果你不知道是否需要 Redux, 那就是不需要它. “ 虽然有这样一句话, 可是作为开发, 却是必须要学会使用的, 只有你会了以后, 才可以来探讨你的项目里面是否需要Redux. Fluxreact为我们的整个应用提供了界面搭建的方法, 如果你的组件够多, 那么就可以像拼积木一样一点点搭建你的应用. 而react的Render是一个纯函数, 只要组件有同样的state和props, 那么你就会得到同样的view. 而Flux的理念就是使state变成不可写, 而是由action分发的方式在内部处理好数据, 再传给state, 而避免组件自己随意修改state造成不可预知的问题. ReduxRedux是Flux思想的一种实现方式, 与react结合使用更加方便. 而Redux的设计思想很简单, 就两句话: 应用是一个状态机, 视图与状态是一一对应的. 所有的状态, 保存在一个对象里面. 基本概念store在整个应用中, 只有一个store, 它保存着所有数据. 如果想得到某个时间点的数据, 就需要对store生成快照, 生成快照的方法是store.getState(), 那么这个快照自然就叫做state了. 注意, 此state和组件里面的state不是一个概念, 也不会有直接的交集. Redux规定, 一个state对应一个view, 只要state是相同的, 那么生成的view应该也是一样的. actionstate已经有了数据, 那么自然就需要有改变数据的方式, 这个方式就是action, 同时也是唯一的方式. 对于view, 不能直接接触到state和store, 只能通过发送action的方式来改变store. action是一个对象, 其中type属性是必须的, 其他属性都属于携带的信息, 一般通过payload来传递. 1234const action = { type: 'ADD_TODO', payload: {},}; action creatoraction既然是一个对象, 那么创建这个对象肯定不会是手写, 而是有一个方法来自动生成, 那么生成这个action的方法即action creator. 123456static addTodo(v) { return { type: ActionType.ADD_TODO, payload: v, }} addTodo函数即为ADD_TODO的action creator. dispatch有了action creator和生成的action, 那么怎么让store知道这个action呢, store.dispatch(action)就是用来发出action的唯一方法. reducer声明和使用当调用store.dispatch之后, 怎么去改变state呢, 这就是reducer的功能了. 每个reducer都是一个函数, 它的参数是当前state和action, 返回值是一个新的state, 这样view就会根据新的state去绘制界面了. 12345678910const defaultState = 0;const reducer = (state = defaultState, action) =&gt; { switch (action.type) { case ActionType.ADD_TODO: return state + action.payload; default: return state; }};const store = createStore(reducer); 当创建好reducer函数之后, 需要让store知道这个函数, 然后store会在调用dispatch时, 自动触发所有的reducer函数. createStore中的reducer参数就是让store去连接指定的reducer方法. 纯函数reducer必须是一个纯函数, 意义是每次执行会得到相同的结果. 所以不能调用Data.now()或Math.random()等方法. 但是由于是纯函数, 基于函数式编程的理念, 是不能改变原始对象的. 所以如果是对象, 返回值应该是return { ...state, ...newState }. 如果对象结构层级特别深, 那么创建newState就会是一个很麻烦的事情, 而且可能会不小心改变state后也会出现其他错误, 这就是为什么需要immutable的原因. subscribestore提供subscribe方法来设置一个监听函数, 只要state发生改变, 那么就会执行这个监听函数. subscribe方法返回一个解除监听的函数unsubscribe, 执行unsubscribe就可以取消监听. 12let unsubscribe = store.subscribe(() =&gt; console.log(store.getState()));unsubscribe(); 工具函数combineReducers一般都会用到的函数, 如果你的reducer有很多个, 那么你就需要用到这个函数创建出一个rootReducers对象来提供给store连接reducer函数. 1234const RootReducer = combineReducers({ todoReducer: todoReducer,});const store = createStore(RootReducer); connectconnect方法可以为你的展示组件创建对应的容器组件. connect方法签名为connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options]). mapStateToProps(state, ownProps) : stateProps mapDispatchToProps(dispatch, ownProps): dispatchProps mergeProps(stateProps, dispatchProps, ownProps): props options为选项, 使用到的地方很少 mapStateToProps(state, ownProps) : stateProps从名字可以看出, 此函数是把state的属性赋给props(此处state非组件state, 而是store的state). 当state变化, 或者ownProps变化的时候, mapStateToProps都会被调用(此处ownProps是上级组件的props传入到connect生成的高阶组件的props, 不是被connect的组件的ownProps), 计算出一个新的props更新给组件, 并触发组件的componentWillReceiveProps方法. 12345const mapStateToProps = (state, ownProps) =&gt; { return { count: state.count, }} mapDispatchToProps(dispatch, ownProps): dispatchProps从名字也可以看出来, 是把dispatch方法映射到props上, 不过没有mapStateToProps那么直观. 在ownProps变化时, mapDispatchToProps 也会再次执行, 计算出一个新的值更新到props上. 12345const mapDispatchToProps = (dispatch, ownProps) =&gt; { return { addTodo: (v) =&gt; dispatch(action.addTodo(v)), }} 传入这个函数以后, 在组件的props上, 就可以使用addTodo方法了.redux提供了bindActionCreators用来快速将action生成可调用的函数. 12345const mapDispatchToProps = (dispatch, ownProps) =&gt; { return bindActionCreators({ addTodo: action.addTodo, })} mergeProps(stateProps, dispatchProps, ownProps): props这个函数就是用来将上面两个函数生成的值复制到props里面的函数, 如果不传这个函数, 默认调用的是Object.assign方法. createStorecreateStore(reducer, initialState, enhancer): store是创建store的唯一方法, reducer即全部的reducers, initialState为store的初始化值, enhancer即可以让我们生成加强版本的store的方法. 1234567891011//createStore中enhancer有关的源码if (typeof preloadedState === 'function' &amp;&amp; typeof enhancer === 'undefined') { enhancer = preloadedState; preloadedState = undefined;}if (typeof enhancer !== 'undefined') { if (typeof enhancer !== 'function') { throw new Error('Expected the enhancer to be a function.'); } return enhancer(createStore)(reducer, preloadedState);} 可以看到enhancer应该是一个方法, 接收createStore作为参数, 返回一个新createStore的方法, 再传入reducer, preloadedState参数执行. applyMiddlewareapplyMiddleware方法生成的函数即enhancer所表示的值, 从enhancer实现可以看出, applyMiddleware有两种调用方式. 12345//1const createStoreWithMiddleware = applyMiddleware(...middleware)(createStore);const store = createStoreWithMiddleware(reducer, preloadedState);//2const store = createStore(reducer, preloadedState, applyMiddleware(...middleware)); ReduxThunk重点说说ReduxThunk中间件, 它是与后台交互的必备中间件, 使我们在dispatch中可以发出异步的action. 它的源码也是十分简单. 123456789101112131415function createThunkMiddleware(extraArgument) { return function ({ dispatch, getState }) { return function (next) { return function (action) { if (typeof action === 'function') { return action(dispatch, getState, extraArgument); } return next(action); }; }; };}var thunk = createThunkMiddleware();thunk.withExtraArgument = createThunkMiddleware;export default thunk; 使用的时候也很简单. 12345678910111213static addTodo(v) { return (dipatch, getState) =&gt; { return Service.addTodo(v).then( (resultValue) =&gt; { let action = { type: ActionType.ADD_TODO, payload: resultValue, }; dipatch(action); }, ); };} ProviderProvider严格来说应该是组件, 不过class本质也是function, 所以放在一起了. Provider组件即让整个应用都可以直接拿到store的组件. 原理是react中的context. 123456789101112131415161718192021//源码class Provider extends Component { getChildContext() { return { store: this.props.store }; } render() { return this.props.children; }}Provider.childContextTypes = { store: React.PropTypes.object}//使用ReactDOM.render( &lt;Provider store={store}&gt; &lt;App /&gt; &lt;/Provider&gt;, document.querySelector(&quot;#container&quot;))","link":"/2017/2017-08-03-react-day-3/"},{"title":"react 4 - immutable","text":"这是应该是基本系列的最后一节了. 上节使用了redux, 在redux的reducer里面的返回值应该是一个新的state对象, 而不是在旧的state对象上进行修改, 那么在ES6语法中, 就需要写很多{...state, ...newState}这种代码来创建新对象. 而且如果改变的值的所在对象层次比较深, 那么这样的代码写起来就很痛苦了. 为此, Facebook专门创建了一个库用于解决这种问题 - immutable. 引入immutable后, 整个应用的state应该都变为immutable类型, 那么在createStore时就需要修改一下初始值. 1const store = createStore(RootReducer, Immutable.Map(), applyMiddleware(...middleware)); 然后, 在combineReducers时候, 原来的state是直接使用=赋值替换的, 整个state变成immutable后, 语法也应该变成immutable提供的set方法, 那么combineReducers就需要重写了. 不过幸运的是, 已经有人把这项工作做好了. 使用redux-immutable包提供的combineReducers来替换原来redux提供的combineReducers. 123//import { combineReducers } from 'redux';import { combineReducers } from 'redux-immutable';const RootReducer = combineReducers({...}); 这两项工作做好以后, 我们就可以在reducer和component里使用immutable的数据结构了. 12345678const reducer = (state = defaultState, action) =&gt; { switch (action.type) { case ActionType.ADD_TODO: return state.update('value', (v) =&gt; (v + action.payload)); default: return state; }} 然后需要把router也整合进来, 构成react-router, react-redux, immutable的最佳开发环境. router本身就提供结合redux的方法, 需要自己改动的并不多. 首先需要改造我们的store创建过程. 123456789101112131415161718import { createStore, applyMiddleware } from 'redux';import ReduxThunk from 'redux-thunk';import { routerMiddleware } from 'react-router-redux';import Immutable from 'immutable';import { createLogger } from 'redux-logger';import { createBrowserHistory } from 'history';import RootReducer from './../_reducer'; // 所有的reducerlet history = createBrowserHistory();const middleware = [routerMiddleware(history), ReduxThunk];const initialState = Immutable.Map();const store = createStore(RootReducer, initialState, applyMiddleware(...middleware));export default store;export { history }; 这样创建的store就已经支持了router, 然后我们再加入router的reducer. 123456789101112131415161718192021//router-reducer.jsimport Immutable from 'immutable';import { LOCATION_CHANGE, } from 'react-router-redux';const initialState = Immutable.fromJS({ location: null,});export default function routerReducer(state = initialState, action) { if (action.type === LOCATION_CHANGE) { return state.set('location', Immutable.fromJS(action.payload)); } return state;};export const reducerName = 'routing';//reducer.jsimport { combineReducers } from 'redux-immutable';import routerReducer, { reducerName as routerReducerName } from './../route/route-reducer';const RootReducer = combineReducers({ [routerReducerName] : routerReducer, ...,});export default RootReducer; 这样, router便与immutable能结合使用了.我们再给我们的store做点增强.redux-logger是一个很常见的中间件, 可以为我们的每个action提供日志记录, 我们也将它加入. 12345import logger from 'redux-logger';if (process.env.NODE_ENV === 'development') { //在开发环境下可以看到log middleware.push(logger);} 但是这样生成的log在控制台显示的全是immutable对象, 并不是直接的js对象, 不方便展开查看. 去看redux-logger源码, 发现它也提供一个createLogger方法来让我们自己创建自己的logger. 1234567891011121314151617181920212223242526272829303132const defaultLogger = ({ dispatch, getState } = {}) =&gt; { if (typeof dispatch === 'function' || typeof getState === 'function') { return createLogger()({ dispatch, getState }); }};export { defaults, createLogger, defaultLogger as logger };export default defaultLogger;//createLoggerfunction createLogger(options = {}) { const loggerOptions = Object.assign({}, defaults, options); ...}//改造logger, 其实等于创建一个自己的中间件import { createLogger } from 'redux-logger';if (process.env.NODE_ENV === 'development') { //在开发环境下可以看到log middleware.push(({ dispatch, getState }) =&gt; { return createLogger({ collapsed: true })({//collapsed还可以是个action dispatch, getState: () =&gt; { return getState().toJS(); } }); });}//官方推荐做法是import { Iterable } from 'immutable';const stateTransformer = (state) =&gt; { if (Iterable.isIterable(state)) return state.toJS(); else return state;};const logger = createLogger({ stateTransformer,}); 到目前为止, 一个react + react-router + react-redux + immutable的开发环境工程就搭建完成了.","link":"/2017/2017-08-04-react-day-4/"},{"title":"react 高阶组件和 ES6 修饰器","text":"在以前使用createClass创建组件的时候, react提供mixin方法将其他公用方法注入组件. 但是在extends Component时, 我们可以使用高阶组件以及@decorator来解决这个问题. 高阶组件的原理很简单: 提供一个函数, 函数接受一个组件, 返回一个新的组件. 由于js的特性, 组件也是一个函数, 也可以用来被继承, 所以出现了两种使用方式. 以子组件方式渲染原始组件(Props Proxy) 1234567function ppHOC(WrappedComponent) { return class PP extends React.Component { render() { return &lt;WrappedComponent {...this.props} /&gt;; } };} 在这个高阶组件里, 你可以做一切想做的事情, 包括拦截props, 或者获取子组件实例, 用其他元素包裹原始组件等. 常用的connect方法就是一个这样的函数. 新组件继承子组件(Inheritance Inversion) 1234567function iiHOC(WrappedComponent) { return class Enhancer extends WrappedComponent { render() { return super.render(); } };} 如同代码里看到的, 这种继承方式可以修改子组件的生命周期函数, 可以拦截子组件的render返回值, 并修改(这种情况对子组件是函数式组件无效). 一般用作拦截生命周期比较常见. 使用方法 普通的用法, 类似let HighComponent = connect(...)(Component) ES6提供的修饰器语法 12@connect(params)class MyComponent extends React.Component {...} 再来介绍下修饰器语法提供的一些便利.比如, 想在开发阶段, 把所有有生命周期的组件函数, 在经历生命周期时候, 提供一个日志记录. 这种时候就是使用修饰器方法的时候了. 123456789101112131415function componentLogger(target) { if (process.env.NODE_ENV !== 'development') { return target; } for (const func in funcColors) { if (target.prototype[func]) { ...//相关操作 } } return target;}export default componentLogger;//使用@componentLoggerclass MyComponent extends React.Component {...} 修饰器如果有参数, 一般都可以做得通用一点, 判断如果传入值是function时, 直接使用默认值加载修饰器, 如果传入值是object时, 作为options生成一个新的修饰器, 修饰所需要的内容. 123456789101112131415161718192021222324252627282930313233343536373839404142function ngCmd(arg) { if (_.isFunction(arg)) { const Wrapper = arg; return class WrapperComponent extends React.Component { render() { return &lt;NgCmd {...this.props} &gt;&lt;Wrapper {...this.props} /&gt;&lt;/NgCmd&gt;; } } } else if (_.isArray(arg)) { let i = 0; let args = []; if (arg.length == 0) { args = ['if', 'show', 'hide']; } else { ['if', 'show', 'hide'].forEach((value, index) =&gt; { if (arg.indexOf(value) &gt; -1) { i++; } }) if (i == 0) { throw 'need at least one ng-cmd'; } args = arg; } return (Wrapper) =&gt; { return class WrapperComponent extends React.Component { render() { let cmdsObj = {}; ['if', 'show', 'hide'].forEach((v, i) =&gt; { if (args.indexOf(v) &gt; -1 &amp;&amp; _.has(this.props, v)) { cmdsObj[v] = this.props[v]; } }) return &lt;NgCmd {...cmdsObj} &gt;&lt;Wrapper {...this.props} /&gt;&lt;/NgCmd&gt;; } } } if (_.has(cmdsObj, 'if') &amp;&amp; cmdsObj['if'] == false) { return null; } }}","link":"/2017/2017-08-10-react-higher-order-components/"},{"title":"react component context","text":"在之前看react-redux时, 说到Provider组件是使用context来实现的, 现在就来看看context到底是个什么东西. 按照官方推荐的意思是, 尽量少使用context, 因为可能会造成应用程序不稳定, 而且作为实验性的 API, 可能会在未来版本移除. 好了, 警告看完了, 下面来继续使用它吧. 基本用法context是帮助你的应用更简单的传递多层数据的工具. 就如同Provider组件, 提供了一个store``props, 那么它的子级不管多深, 只需要connect一下, 便可以拿到该store, 完全没有props传递链的那种复杂写法. 12345678910111213class Provider extends Component { getChildContext() { return { store: this.props.store, }; } render() { return this.props.children; }}Provider.childContextTypes = { store: PropTypes.object,}; Provider的实现方法就差不多是这个样子, 通过它来学习context怎么使用. 首先, 提供数据的组件需要实现getChildContext方法, 返回一个对象, 对象值即为能提供的所有属性值, 还需要定义childContextTypes, 表示下级可以获取到的所有属性值. 如果没有定义childContextTypes, 那么下级的context将得到一个空对象.connect返回的是一个高阶组件, 这个组件定义了contextTypes, 然后就可以在组件相关生命周期函数里面获取到对应的值了. 123ConnectComponent.contextTypes = { store: PropTypes.object.isRequired,}; 生命周期函数context在如下五个生命周期函数里面都可以获取和使用: constructor(props, context) componentWillReceiveProps(nextProps, nextContext) shouldComponentUpdate(nextProps, nextState, nextContext) componentWillUpdate(nextProps, nextState, nextContext) componentDidUpdate(prevProps, prevState, prevContext) 无状态组件在无状态组件中也可以使用context, 会和props一样, 作为函数的第二个参数传入. 123456function FuncComponent(props, context) { return &lt;div&gt;{this.context.user.name}&lt;/div&gt;;}FuncComponent.contextTypes = { user: React.PropTypes.object.isRequired,}; 注意shouldComponentUpdate和props以及state一样, 当上级改变context时候, 会触发下级的相关生命周期函数, 在shouldComponentUpdate返回true时进行重新渲染.而与props和state不同的地方在于, context是可以跨组件传递的. 这就意味着, 可能有部分中间的组件并没有使用context, 而它们的props和state并没有变化, 在shouldComponentUpdate返回false的时候停止了子树的更新, 而子组件是使用context获取上层数据, 但是并没有被触发更新. 这就是为什么react-router需要使用withRouter来包裹connect以后的组件, 因为在connect中实现了shouldComponentUpdate, 会截断子树的render.所以react官方并不推荐更新context, 它应该作为一个固定的值来被全局使用, 否则可能在某些深层组件可能会出现意外的bug.","link":"/2017/2017-08-19-react-context/"},{"title":"react 组件结合 jquery 组件","text":"看接下来的内容之前, 需要明白react以及github上已经提供了足够多的控件来供平常使用, 需要控件的时候可以查看. 如antd, react-components等. 这篇文章只是提供一个改造方案的解决思路, 如果有某些特殊需求的控件需要实现才手动改造. 引入jquery比较推荐全局引入jquery包, 减少打包的依赖而且有cdn可用, 引入其他jquery插件时也比较方便. 坏处是会暴露全局变量$, 不过并不是特别大影响. 如果不想全局引入, 可以在webpack里设置alias和ProvidePlugin结合expose-loader, 也可以达到类似全局效果(通过expose-loader和ProvidePlugin自动解析$变量), 引入其他插件. 引入插件包jquery全局可用以后, 插件包在什么地方加载都没区别, 可以在页面上引入, 也可以使用import. 这次拿来改造举例的是datetime-picker这个插件. 改造插件首先创建自己的组件, 由于是结合jquery, 那么肯定有自己的生命周期函数. 顺便带上componentLogger做生命周期日志. 123456789101112131415161718192021222324import React from 'react';import { PropTypes as P } from 'prop-types';import _ from 'lodash';import classNames from 'classnames';import { componentLogger } from './../../common/decorators';@componentLoggerclass DateTimePicker extends React.PureComponent { static propTypes = {}; constructor(props) { super(props); this.state = {}; } componentDidMount() {} componentWillReceiveProps(nextProps) {} componentDidUpdate() {} render() { return null; } componentWillUnmount() {}}export default DateTimePicker; 先在render中写好结构和样式, 给上ref, 为使用jquery做准备. 这里为了方便自定义样式, 外层div和内层input的className都可以通过props传入. 123456render() { return (&lt;div className={classNames(&quot;date-time-picker input-group date&quot;, this.props.className)} ref=&quot;pickerDiv&quot;&gt; &lt;input ref=&quot;pickerInput&quot; type=&quot;text&quot; readOnly className={classNames(&quot;form-control&quot;, this.props.inputClassName)} {...this.state.inputProps} /&gt; &lt;span className=&quot;input-group-addon&quot;&gt;&lt;span className=&quot;glyphicon glyphicon-calendar&quot;&gt;&lt;/span&gt;&lt;/span&gt; &lt;/div&gt;)} 然后给它在componentDidMount中加上初始化函数. 12345678910111213141516componentDidMount() { this.resetDateTimePicker(this.state.options); this.refs.pickerInput.value = this.props.value;}resetDateTimePicker(options) { $(this.refs.pickerDiv).datetimepicker(options) .on('changeDate', (event) =&gt; { if (this.refs.pickerInput.value != this.props.value) { this.props.onChange({ target: this.refs.pickerInput, stopPropagation: event.stopPropagation, preventDefault: event.preventDefault, }); } });} 这里的options便是插件文档中给定可以设置的options了, 需要让它有默认值而且也可以从外部传入, 那么实现的地方应该在constructor和componentWillReceiveProps两个地方了. 123456789101112constructor(props) { super(props); this.state = { ...splitDateTimePickerOptionsAndInputProps(props), }}componentWillReceiveProps(nextProps) { this.setState(...splitDateTimePickerOptionsAndInputProps(nextProps)); if (nextProps.value != this.props.value) { this.refs.pickerInput.value = nextProps.value; }} splitDateTimePickerOptionsAndInputProps这个函数即从props里拿到设置值和混合默认值的函数. 12345678910111213141516171819202122232425262728const defaultDateTimePickerOptions = { language: 'zh-CN', format: &quot;yyyy-mm-dd&quot;, autoclose: true, todayHighlight: true, forceParse: true, minView: 2, maxView: 5, todayBtn: true,};const needRemoveInputProps = ['onChange', 'value', 'className', 'inputClassName'];const splitDateTimePickerOptionsAndInputProps = (props) =&gt; { const propsKeyStartsWith = 'dateTime'; let options = { ...defaultDateTimePickerOptions, }; let inputProps = {}; for (let key in props) { if (key.startsWith(propsKeyStartsWith)) { options[key.substring(propsKeyStartsWith.length)] = props[key]; } else if (needRemoveInputProps.indexOf(key) == -1) { inputProps[key] = props[key]; } } return { options, inputProps };} 需要注意的是, defaultDateTimePickerOptions, needRemoveInputProps, splitDateTimePickerOptionsAndInputProps这种可能会改变或变动的代码, 最好写在组件外面. defaultDateTimePickerOptions即如果没有传入相关设置值的清空下使用的默认值, needRemoveInputProps表示这些值是特殊的, 不会传递到input组件上, 其他的值提取出来后都可以传递到input组件上. 在splitDateTimePickerOptionsAndInputProps函数中, 把以dateTime开头的props都拿出来, 放到options对象中, 其他的放到inputProps对象中, 最后将它们返回. 不过现在还有个问题, 如果外面的props改变了, 控件需要重新加载. 1234567891011componentWillReceiveProps(nextProps) { this.setState({...splitDateTimePickerOptionsAndInputProps(nextProps)}); if (nextProps.value != this.props.value) { this.refs.pickerInput.value = nextProps.value; }}componentDidUpdate(prevProps, prevState) { if (!_.isEqual(prevState.options, this.state.options)) { this.resetDateTimePicker(this.state.options); }} 为了优化性能, 这里使用了lodash来深度比较两个对象, 如果有不同的options, 才重置DateTimePicker. 再在componentWillUnmount中加上析构函数 123componentWillUnmount() { $(this.refs.pickerDiv).datetimepicker('remove');} 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100import React from 'react';import { PropTypes as P } from 'prop-types';import _ from 'lodash';import classNames from 'classnames';import { componentLogger } from './../../common/decorators';const defaultDateTimePickerOptions = { language: 'zh-CN', format: 'yyyy-mm-dd', autoclose: true, todayHighlight: true, forceParse: true, minView: 2, maxView: 5, todayBtn: true,};const needRemoveInputProps = ['onChange', 'value', 'className', 'inputClassName'];const splitDateTimePickerOptionsAndInputProps = (props) =&gt; { const propsKeyStartsWith = 'dateTime'; let options = { ...defaultDateTimePickerOptions, }; let inputProps = {}; for (let key in props) { if (key.startsWith(propsKeyStartsWith)) { options[key.substring(propsKeyStartsWith.length)] = props[key]; } else if (needRemoveInputProps.indexOf(key) == -1) { inputProps[key] = props[key]; } } return { options, inputProps };};@componentLoggerclass DateTimePicker extends React.PureComponent { static propTypes = {}; constructor(props) { super(props); this.state = { ...splitDateTimePickerOptionsAndInputProps(props), }; } resetDateTimePicker(options) { $(this.refs.pickerDiv) .datetimepicker(options) .on('changeDate', (event) =&gt; { if (this.refs.pickerInput.value != this.props.value) { this.props.onChange({ target: this.refs.pickerInput, stopPropagation: event.stopPropagation, preventDefault: event.preventDefault, }); } }); } componentDidMount() { this.resetDateTimePicker(this.state.options); this.refs.pickerInput.value = this.props.value; } componentWillReceiveProps(nextProps) { this.setState({ ...splitDateTimePickerOptionsAndInputProps(nextProps) }); if (nextProps.value != this.props.value) { this.refs.pickerInput.value = nextProps.value; } } componentDidUpdate(prevProps, prevState) { if (!_.isEqual(prevState.options, this.state.options)) { this.resetDateTimePicker(this.state.options); } } render() { return ( &lt;div className={classNames('date-time-picker input-group date', this.props.className)} ref='pickerDiv'&gt; &lt;input ref='pickerInput' type='text' readOnly className={classNames('form-control', this.props.inputClassName)} {...this.state.inputProps} /&gt; &lt;span className='input-group-addon'&gt; &lt;span className='glyphicon glyphicon-calendar'&gt;&lt;/span&gt; &lt;/span&gt; &lt;/div&gt; ); } componentWillUnmount() { $(this.refs.pickerDiv).datetimepicker('remove'); }}export default DateTimePicker;//使用&lt;span className='toolbar-search '&gt; &lt;span className='toolbar-search-label'&gt;选择时间:&lt;/span&gt; &lt;DateTimePicker type='text' placeholder='请选择时间' {...dataValueBindHandler(this, 'searchParam', 'CompleteTime')} inputClassName='toolbar-search-input' /&gt;&lt;/span&gt;;","link":"/2017/2017-08-22-react-component-with-jquery/"},{"title":"像 angular 一样使用 react 组件","text":"前言写过angularjs的应该对ng-if, ng-show, ng-repeat等内置指令比较熟悉, 在react里面一般都是用js来实现这些功能, 但是这种组件化(指令化)的书写方式比较简单易懂和便于维护, 比一个接一个的if,map,&amp;&amp;,||嵌套简洁得多, 所以可以自己实现几个指令, 方便使用. 需要更多的时候也可以自己再扩展. ng-ifng-if可以说是很简单的指令了, 当if条件为真时, 展示组件, 否则不展示. 123456789101112131415161718192021const NgCmd = ({ if: _if = true, children } = props) =&gt; { if (!_if || !children) return null; return children;};NgCmd.propTypes = { if: React.PropTypes.any,};//使用ReactDOM.render( &lt;div&gt; &lt;NgCmd if={true}&gt; &lt;div&gt;this is true&lt;/div&gt; &lt;span&gt;true&lt;/span&gt; &lt;/NgCmd&gt; &lt;NgCmd if={false}&gt; &lt;div&gt;this is false&lt;/div&gt; &lt;span&gt;false&lt;/span&gt; &lt;/NgCmd&gt; &lt;/div&gt;, document.querySelector('#container'),); 注意, 该指令在react16 以上版本可用, 因为render函数可以返回数组. 低版本不可以, 需要修改返回值. ng-showng-show和ng-hide还有ng-class可以放在一起说, 因为它们本质上都是改变元素的class. 在react里面不需要特殊的支持, 可以使用classnames插件, 比ng-class更方便. 具体使用方法可以参考文档. 12345&lt;div&gt; &lt;div className={classNames({ hide: this.state.hide })}&gt;ng-hide&lt;/div&gt; &lt;div className={classNames({ hide: !this.state.show })}&gt;ng-show&lt;/div&gt; &lt;div className={classNames({ class-one: this.state.needClassOne })}&gt;ng-class&lt;/div&gt;&lt;/div&gt;, ng-cmd为了提供控制式组件, 实现一个ng-cmd, 包括ng-if和ng-show的功能. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import React from 'react';import { PropTypes as P } from 'prop-types';import _ from 'lodash';const NgCmd = ({ if: _if = true, show = true, hide = false, children } = props) =&gt; { if (!_if || !children) return null; let classHideName = ''; if (!show || hide) { classHideName = 'hide'; } return React.Children.map(children, (child, index) =&gt; { if (_.isString(child) || _.isNumber(child)) { return classHideName ? null : child; } if (!React.isValidElement(child)) { throw `ng-cmd only has React Element`; } let childProps = child.props; let className = ''; if (child.props.className &amp;&amp; classHideName) { className = child.props.className + ' ' + classHideName; } else if (child.props.className || classHideName) { className = child.props.className || classHideName; } return React.cloneElement(child, { ...childProps, key: index, className: className, }); });};NgCmd.propTypes = { hide: P.any, show: P.any, if: P.any,};//使用const Test = () =&gt; { return ( &lt;div&gt; &lt;NgCmd show={false}&gt; &lt;div&gt;show - false&lt;/div&gt; &lt;/NgCmd&gt; &lt;NgCmd show={true}&gt; &lt;div&gt;show - true&lt;/div&gt; &lt;/NgCmd&gt; &lt;NgCmd hide={false}&gt; &lt;div&gt;hide - false&lt;/div&gt; &lt;/NgCmd&gt; &lt;NgCmd hide={true}&gt; &lt;div&gt;hide - true&lt;/div&gt; &lt;/NgCmd&gt; &lt;NgCmd if={false}&gt; &lt;div&gt;if - false&lt;/div&gt; &lt;/NgCmd&gt; &lt;NgCmd if={true}&gt; &lt;div&gt;if - true&lt;/div&gt; &lt;/NgCmd&gt; &lt;/div&gt; );}; 有个问题需要注意的是, 如果NgCmd组件的子元素是一个自定义组件, 那么需要自己接收props.className并使用到顶级节点上, 否则会造成show和hide失效. 顺便提供一个ngCmd装饰器, 用来装饰组件, 即可在组件中直接使用show,hide,if, 不需要使用NgCmd组件. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138//NgCmd for Decorators and function Component -- function Component dont need NgCmdfunction ngCmd(arg) { if (_.isFunction(arg)) { const Wrapper = arg; return class WrapperComponent extends React.Component { render() { return ( &lt;NgCmd {...this.props}&gt; &lt;Wrapper {...this.props} /&gt; &lt;/NgCmd&gt; ); } }; } else if (_.isArray(arg)) { let i = 0; let args = []; if (arg.length == 0) { args = ['if', 'show', 'hide']; } else { ['if', 'show', 'hide'].forEach((value, index) =&gt; { if (arg.indexOf(value) &gt; -1) { i++; } }); if (i == 0) { throw 'need at least one ng-cmd'; } args = arg; } return (Wrapper) =&gt; { return class WrapperComponent extends React.Component { render() { let cmdsObj = {}; ['if', 'show', 'hide'].forEach((v, i) =&gt; { if (args.indexOf(v) &gt; -1 &amp;&amp; _.has(this.props, v)) { cmdsObj[v] = this.props[v]; } }); return ( &lt;NgCmd {...cmdsObj}&gt; &lt;Wrapper {...this.props} /&gt; &lt;/NgCmd&gt; ); } }; }; if (_.has(cmdsObj, 'if') &amp;&amp; cmdsObj['if'] == false) { return null; } }}const Test = () =&gt; { return ( &lt;div&gt; &lt;NgCmd show={false}&gt; &lt;Test2 /&gt; &lt;/NgCmd&gt; &lt;NgCmd show={true}&gt; &lt;Test2 /&gt; &lt;/NgCmd&gt; &lt;NgCmd show={false}&gt; &lt;Test3 /&gt; &lt;/NgCmd&gt; &lt;NgCmd show={true}&gt; &lt;Test3 /&gt; &lt;/NgCmd&gt; &lt;NgCmd show={false}&gt; &lt;Test4 /&gt; &lt;/NgCmd&gt; &lt;NgCmd show={true}&gt; &lt;Test4 /&gt; &lt;/NgCmd&gt; &lt;NgCmd show={false}&gt; &lt;Test5 /&gt; &lt;/NgCmd&gt; &lt;NgCmd show={true}&gt; &lt;Test5 /&gt; &lt;/NgCmd&gt; &lt;NgCmd if={false}&gt; &lt;Test2 /&gt; &lt;/NgCmd&gt; &lt;NgCmd if={true}&gt; &lt;Test2 /&gt; &lt;/NgCmd&gt; &lt;NgCmd if={false}&gt; &lt;Test3 /&gt; &lt;/NgCmd&gt; &lt;NgCmd if={true}&gt; &lt;Test3 /&gt; &lt;/NgCmd&gt; &lt;NgCmd if={false}&gt; &lt;Test4 /&gt; &lt;/NgCmd&gt; &lt;NgCmd if={true}&gt; &lt;Test4 /&gt; &lt;/NgCmd&gt; &lt;Test4 if={true} /&gt; &lt;Test4 if={false} /&gt; &lt;Test4 show={true} /&gt; &lt;Test4 show={false} /&gt; &lt;Test4 hide={true} /&gt; &lt;Test4 hide={false} /&gt; &lt;Test5 if={true} /&gt; &lt;Test5 if={false} /&gt; &lt;Test5 show={true} /&gt; &lt;Test5 show={false} /&gt; &lt;Test5 hide={true} /&gt; &lt;Test5 hide={false} /&gt; &lt;Test6 if={true} /&gt; &lt;Test6 if={false} /&gt; &lt;Test6 show={true} /&gt; &lt;Test6 show={false} /&gt; &lt;Test6 hide={true} /&gt; &lt;Test6 hide={false} /&gt; &lt;/div&gt; );};const Test2 = () =&gt; { return 'Test2';};const Test3 = (props) =&gt; { return &lt;div&gt;Test3&lt;/div&gt;;};@ngCmdclass Test4 extends React.Component { render() { return &lt;div className={this.props.className}&gt;Test4-{JSON.stringify(this.props)}&lt;/div&gt;; }}@ngCmd(['hide', 'if'])class Test5 extends React.Component { render() { return &lt;div&gt;Test5-{JSON.stringify(this.props)}&lt;/div&gt;; }}const Test6 = ngCmd((props) =&gt; { return &lt;div className={props.className}&gt;Test6-{JSON.stringify(props)}&lt;/div&gt;;}); ng-switch另一个比较有用的控件为ng-switch, 否则在react中使用switch只能使用立即执行函数. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970var Test = (props) =&gt; { return (&lt;div className=&quot;test&quot;&gt; //不使用NgSwitch {(function(){ switch(props.value){ case '1':return &lt;div&gt;one&lt;/div&gt;; case '2':return &lt;div&gt;two&lt;/div&gt;; case '3':return &lt;div&gt;threee&lt;/div&gt;; default : return &lt;div&gt;default&lt;/div&gt;; } })()} //使用NgSwitch &lt;NgSwitch when={props} get={(v) =&gt; (v.a)}&gt; &lt;NgDefault&gt;default&lt;/NgDefault&gt; &lt;NgCase is=&quot;1&quot;&gt;&lt;div&gt;1&lt;/div&gt;&lt;/NgCase&gt; &lt;NgCase is=&quot;2&quot;&gt;2&lt;/NgCase&gt; &lt;NgCase is=&quot;3&quot;&gt;3&lt;/NgCase&gt; &lt;/NgSwitch&gt; &lt;/div&gt;)&lt;Test value=&quot;1&quot;/&gt;&lt;Test value=&quot;2&quot;/&gt;&lt;Test value=&quot;3&quot;/&gt;&lt;Test value=&quot;4&quot;/&gt;//NgSwitch.jsimport React from 'react';import { PropTypes as P } from 'prop-types';import _ from 'lodash';import Immutable from 'immutable';const NgSwitch = ({ when, get, children, } = props) =&gt; { if (_.isNil(when) || _.isNil(children)) { return null; } let child = null; let defaultChild = null; React.Children.forEach(children, function (element) { if (!React.isValidElement(element)) return; if (element.type != NgCase &amp;&amp; element.type != NgDefault) return; if (element.type == NgDefault &amp;&amp; !defaultChild) { defaultChild = element; return; } else if (element.type == NgDefault &amp;&amp; defaultChild) { throw 'ng-switch can not has two default' } if (child == null &amp;&amp; element.props.is == (_.isFunction(get) ? get(when) : when)) { child = element; } }); return child || defaultChild;};NgSwitch.propTypes = { when: P.any.isRequired, get: P.func,}const NgCase = ({ is, children } = props) =&gt; { if (!is) { return null; } return children;};NgCase.propTypes = { is: P.any.isRequired,}const NgDefault = ({ children, } = props) =&gt; { return children;};} 在NgSwitch组件中, 可以自定义获取函数get, 如果使用的是immutable, 只需要设置get={(v) =&gt; (v.get('value'))}即可. ng-repeatng-repeat作为angular里面的一大利器, 使得循环一个dom结构再也不是很麻烦的事情, 结合ng-if以及ng-class, 可以方便的定义重复元素. 这里也仿造ng-repeat实现一个循环组件, 而且不会有像ng-repeat造成性能不好的问题, 和原始的map写法相比性能可能还有提升(有提供测试 demo, 可以自行测试). 同时为了方便项目组使用, 兼容immutable数据结构和原生数据结构, 提供自定义key(track by), filter函数, sortBy函数. 内置提供$$index, $$isOdd, $$total等相关属性. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155import React from 'react';import { PropTypes as P } from 'prop-types';import _ from 'lodash';import Immutable from 'immutable';const NgFor = ({ for: _for, of: _of = 'item', filter = null, sortBy = null, trackBy = null, render } = props) =&gt; { if (!_for || !render) { return; } const _obj = {}; if (Immutable.isCollection(_for)) { if (filter) { _for = _for.filter(filter); } const _size = _for.count(); if (_size == 0) { return null; } return _for .sortBy((v) =&gt; v[sortBy]) .map((value, index) =&gt; { _obj[_of] = value; const key = Immutable.fromJS(value).get(trackBy) || index; var ele = render({ ..._obj, $$index: index, $$isEnd: index + 1 === _size, $$isStart: index === 0, $$isOdd: index % 2 != 0, $$isEven: index % 2 == 0, $$total: _size, $$key: key, key: key, }); //when you need High performance, you need set the 'key' props by yourself ?? not sure return ele.key ? ele : React.cloneElement(ele, { key }); }); } else { _for = _.filter(_for, filter); const _size = _.size(_for); if (_size == 0) { return null; } return _.map(_.sortBy(_for, sortBy), (value, index) =&gt; { _obj[_of] = value; const key = value[trackBy] || index; var ele = render({ ..._obj, $$index: index, $$isEnd: index + 1 === _size, $$isStart: index === 0, $$isOdd: index % 2 != 0, $$isEven: index % 2 == 0, $$total: _size, $$key: key, key: key, }); return ele.key ? ele : React.cloneElement(ele, { key }); }); }};NgFor.propTypes = { for: P.any.isRequired, of: P.string.isRequired, filter: P.func, sort: P.func, trackBy: P.string,};NgFor.defaultProps = { of: 'item',};var Test = (props) =&gt; { var start = [ { id: 'a1', value: 'av1' }, { id: 'a2', value: 'av2' }, { id: 'a3', value: 'av3' }, ]; var arrays = []; for (var i = 0; i &lt; 5000; i++) { //for (var i = 0; i &lt; 20000; i++) { arrays.push({ id: 'a1', value: 'av1', }); } var arraysIm = Immutable.fromJS(arrays); return ( &lt;div className='test'&gt; {console.log('NgFor no set self key')} {console.time('NgFor no set self key')} &lt;NgFor for={arrays} of='item' render={function (_props) { return ( &lt;div id={_props.item.id}&gt; {_props.item.value} &amp;nbsp;length: {arrays.length} &lt;/div&gt; ); }} &gt;&lt;/NgFor&gt; {console.timeEnd('NgFor no set self key')} {console.log('NgFor set self key')} {console.time('NgFor set self key')} &lt;NgFor for={arrays} of='item' render={function (_props) { return ( &lt;div id={_props.item.id} key={_props.key}&gt; {_props.item.value} &amp;nbsp;length: {arrays.length} &lt;/div&gt; ); }} &gt;&lt;/NgFor&gt; {console.timeEnd('NgFor set self key')} {console.log('NgFor Immutable set self key')} {console.time('NgFor Immutable set self key')} &lt;NgFor for={arraysIm} of='item' render={function (_props) { return ( &lt;div id={_props.item.get('id')} key={_props.key}&gt; {_props.item.get('value')} &amp;nbsp;length: {arraysIm.count()} &lt;/div&gt; ); }} &gt;&lt;/NgFor&gt; {console.timeEnd('NgFor Immutable set self key')} {console.log('js Map set self key')} {console.time('js Map set self key')} {arrays.map((value, index) =&gt; { return ( &lt;div id={value.id} key={index}&gt; {value.value} &amp;nbsp;length: {arrays.length} &lt;/div&gt; ); })} {console.timeEnd('js Map set self key')} &lt;/div&gt; );};export { Test };export default NgFor; 性能测试截图(5000):","link":"/2017/2017-08-23-react-component-like-angular/"},{"title":"react 中的数据双向绑定","text":"在react中, 如果不使用双向绑定, 那么获取一个受控制的input的数据需要写一个onChange回调函数来获取输入值, 再通过setState来将value传入input做展示. 少量的输入框的情况下, 还可以使用这种方法, 但是如果在比较大和复杂的表单中, 这种写法就会觉得太麻烦了. 旧版本的valueLink在以前的版本中, 可以通过mixin:[LinkedStateMixin]这种方法来实现简易的双向绑定, 它的底层方法是react为input提供的valueLink属性, 可以通过传递一个含有value和requestChange属性的对象, 来实现value和onChange的同时绑定. 但是在react 15中, valueLink已经被标记为deprecated, 如果你继续使用, 会出现提示: Note: LinkedStateMixin is deprecated as of React v15. The recommendation is to explicitly set the value and change handler, instead of using LinkedStateMixin. 而在react 16这个版本中, valueLink已经正式消失了, 对此, react官方的说法是, No easy/messy 2-way data binding with modern React!, 不过这只是说说而已, 来看看新版本的双向绑定怎么实现比较好. 新版本使用当不使用双向绑定的时候, react的做法是为input提供value和onChange属性, 那么如果想简写时, ES6的扩展运算符...则提供了很大的方便性, 我们只需要返回一个含有value和onChange的对象即可. 1234567function twoway(){ return { value : 'value', onChange : function, }}&lt;input {...twoway()}/&gt; 这便是最基础的用法了, 那么基于此来扩展一下. 首先, value所在key肯定是需要作为参数传入的, 而读取和设置state的方法, 也是组件特有的. 那么我们需要直接把组件实例传入即可. 1234567891011function twoway(component, key) { return { value: component.state[key], onChange: (e) =&gt; { component.setState({ [key]: event.target.value, }); }, };}&lt;input {...twoway(this, 'testValue')} /&gt;; 加入path好了, 初步的双向绑定方法就完成了, 下一步来优化它. 首先, 不应该所有的value都是直接保存在state上, 可能是保存在state中某个对象上, 那么所在对象的深层path也应该作为参数传入, 而key是作为state的key传入. 123456789101112131415161718192021222324252627282930313233343536373839import _ from 'lodash';function twoway(component, key, path) { let hasPath = _.isArray(path) &amp;&amp; path.length &gt; 0; if (!hasPath) { return { value: component.state[key], onChange: (event) =&gt; { component.setState({ [key]: event.target.value, }); }, }; } else { return { value: _.get(component.state[key], path), onChange: (event) =&gt; { component.setState({ [key]: { ..._.set(component.state[key] || {}, path, event.target.value) }, }); }, }; }}class Test extends React.Component { constructor(props) { super(props); this.state = {}; } render() { return ( &lt;div&gt; &lt;input {...twoway(this, 'testValue')} /&gt; &lt;input {...twoway(this, 'testValueObject', ['Lv1', 'Lv2'])} /&gt; &lt;div&gt;testValue : {this.state.testValue}&lt;/div&gt; &lt;div&gt;testValueObject : {JSON.stringify(this.state.testValueObject)}&lt;/div&gt; &lt;/div&gt; ); }} 加入immutable支持而我们推荐整个项目里面的对象尽量使用immutable结构, 达到优化性能和避免state对象深度拷贝的目的, 那么twoway方法也需要加入对immutable结构的支持. 顺便也加入对checkbox的支持. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import _ from 'lodash';import Immutable from 'immutable';function twoway(component, key, path) { if (!key) { throw 'dataValueBindHandler to bind state need one key'; } const bindFun = (event) =&gt; { const ele = event.target; const value = ele.type === 'checkbox' ? ele.checked : ele.value; const stateValue = component.state[key] || {}; if (Immutable.isCollection(stateValue)) { const setFuncName = _.isArray(path) ? 'setIn' : 'set'; component.setState({ [key]: path ? component.state[key][setFuncName](path, value) : value, }); } else { component.setState({ [key]: path ? { ..._.set(stateValue, path, value) } : value, }); } }; let value = ''; if (Immutable.isCollection(component.state[key])) { value = path ? component.state[key][_.isArray(path) ? 'getIn' : 'get'](path) : component.state[key]; } else { value = path ? _.get(component.state[key], path) : component.state[key]; } return { value: value, onChange: bindFun, };}class Test extends React.Component { constructor(props) { super(props); this.state = { testValue: '', testValueObject: { Lv1: { Lv2: 'val', }, }, testValueImmutableObject: Immutable.Map().setIn(['Lv1', 'Lv2'], 'valImmutable'), }; } render() { return ( &lt;div&gt; &lt;input {...twoway(this, 'testValue')} /&gt; &lt;input {...twoway(this, 'testValueObject', ['Lv1', 'Lv2'])} /&gt; &lt;input {...twoway(this, 'testValueImmutableObject', ['Lv1', 'Lv2'])} /&gt; &lt;div&gt;testValue : {this.state.testValue}&lt;/div&gt; &lt;div&gt;testValueObject : {JSON.stringify(this.state.testValueObject)}&lt;/div&gt; &lt;div&gt;testValueImmutableObject : {JSON.stringify(this.state.testValueImmutableObject)}&lt;/div&gt; &lt;/div&gt; ); }} 加入onChange方法缓存对于这个函数, 还可以再优化一下, 因为每次执行twoway方法, 都会生成一个新的bindFun函数, 如果你的input使用的是自定义组件, 则会因为改变props中onChange变化而不是value变化而执行render函数, 那么需要将onChange变成一个固定的函数, 不需要每次重新生成, 则不会因为变化onChange而不是value时触发子组件的render函数了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import React from 'react';import _ from 'lodash';import Immutable from 'immutable';const dataValueBindHandler = (component, key, path) =&gt; { if (!key) { throw 'dataValueBindHandler to bind state need one key'; } let dataHandleBindMap = component.__dataHandleBindMap || Immutable.Map(); let mapKey = `key:${key}`; if (path) { mapKey += `::path:${_.isArray(path) ? path.join('__') : path}`; } let onChange = null; if (dataHandleBindMap.has(mapKey)) { onChange = dataHandleBindMap.get(mapKey); } else { const bindFun = (event) =&gt; { const ele = event.target; const value = ele.type === 'checkbox' ? ele.checked : ele.value; const stateValue = component.state[key] || {}; if (Immutable.isCollection(stateValue)) { const setFuncName = _.isArray(path) ? 'setIn' : 'set'; component.setState({ [key]: path ? component.state[key][setFuncName](path, value) : value, }); } else { component.setState({ [key]: path ? { ..._.set(stateValue, path, value) } : value, }); } }; component.__dataHandleBindMap = dataHandleBindMap.set(mapKey, bindFun); onChange = bindFun; } let value = ''; if (Immutable.isCollection(component.state[key])) { value = path ? component.state[key][_.isArray(path) ? 'getIn' : 'get'](path) : component.state[key]; } else { value = path ? _.get(component.state[key], path) : component.state[key]; } return { value: value, onChange: onChange, };};export default dataValueBindHandler;class Test extends React.Component { constructor(props) { super(props); this.state = { testValue: '', testValueObject: { Lv1: { Lv2: 'val', }, }, testValueImmutableObject: Immutable.Map().setIn(['Lv1', 'Lv2'], 'valImmutable'), }; } render() { return ( &lt;div&gt; &lt;input {...dataBindHandler(this, 'testValue')} /&gt; &lt;input {...dataBindHandler(this, 'testValueObject', ['Lv1', 'Lv2'])} /&gt; &lt;input {...dataBindHandler(this, 'testValueImmutableObject', ['Lv1', 'Lv2'])} /&gt; &lt;div&gt;testValue : {this.state.testValue}&lt;/div&gt; &lt;div&gt;testValueObject : {JSON.stringify(this.state.testValueObject)}&lt;/div&gt; &lt;div&gt;testValueImmutableObject : {JSON.stringify(this.state.testValueImmutableObject)}&lt;/div&gt; &lt;/div&gt; ); }}","link":"/2017/2017-09-17-react-two-way-data-binding/"},{"title":"react 性能优化之函数绑定","text":"在react中创建组件的时候, 如果有用到回调方法传递到下级组件, 而在方法中需要使用this参数时候, 有两种方法可以使用, 一种是使用bind方法绑定this, 还一种是使用箭头函数绑定this. 一般推荐都是使用bind方法, 因为箭头函数在每次执行render方法时都会重新生成一次, 造成传入的props改变, 重新触发render. 123451.this.childChange = this.childChange.bind(this);&lt;Child onChange={this.childChange}/&gt;2.&lt;Child onChange={(event)=&gt;{this.childChange(event)}}/&gt; 在第 2 种写法中, 当Child组件是PureComponent时, 也会在每次父组件执行render之后执行render, 因为props.onChange属性改变了. 那么, 一般在需要传入回调函数时候, 都使用bind之后的函数就可以了, 但是在某些特殊情况下, 必须要使用箭头函数时, 如何优化呢. 1234567891011childChange(event, index){ ...;}&lt;NgFor for={arraysItem} of=&quot;item&quot; render={ function (_props) { return (&lt;Child onChange={(event)=&gt;{this.childChange(event, _props.$$index)} /&gt;) }}&gt;&lt;/NgFor&gt;{arrays.map((value, index) =&gt; { return (&lt;Child onChange={(event)=&gt;{this.childChange(event, index)} /&gt;)})} 当使用闭包传入值的时候, 即使执行bind后的方法, 也需要在里面使用箭头函数调用, 传入index值. 那么需要用到bind函数的args来优化.自定义一个bindOnce方法, 传入组件和要绑定的方法以及其他参数, 对方法进行bind和缓存. 123456789101112131415161718192021222324import Immutable from 'immutable';var __bindOnce = function (component, func, ...args) { if (!component.__bindFuncs) { component.__bindFuncs = Immutable.Map(); } let __bindFuncs = component.__bindFuncs; let argsMap = Immutable.fromJS(args); if (__bindFuncs.has(func)) { if (__bindFuncs.get(func).has(argsMap)) { return __bindFuncs.get(func).get(argsMap); } else { let bindFunc = func.bind(component, ...args); component.__bindFuncs = __bindFuncs.update(func, (v) =&gt; v.set(argsMap, bindFunc)); return bindFunc; } } else { let bindFunc = func.bind(component, ...args); component.__bindFuncs = __bindFuncs.set(func, Immutable.Map().set(argsMap, bindFunc)); return bindFunc; }};export default bindOnce; 这里使用了immutable的Map来作为缓存字典, 因为Map结构可以使用Object和function作为Key. 使用方法: 1234567891011childChange(index, event){ ...;}&lt;NgFor for={arraysItem} of=&quot;item&quot; render={ function (_props) { return (&lt;Child onChange={bindOnce(this, this.childChange, _props.$$index)} /&gt;) }}&gt;&lt;/NgFor&gt;{arrays.map((value, index) =&gt; { return (&lt;Child onChange={bindOnce(this, this.childChange, index)} /&gt;)})} 可以见到, 唯一需要改变的就是, 在childChange中, event参数的位置在最后, 这是因为onChange总会传入event参数, 而先bind的参数会出现在参数列表前面. 当使用了bindOnce之后, Child便不会因为props中onChange变化而重新render了.","link":"/2017/2017-09-25-react-once-bind-function/"},{"title":"react 异步加载组件","text":"在angular中, 异步加载组件时, 需要加载完mod.js之后使用$provide来将mod注册到angular全局, 才能实现异步组件中指令的加载和识别. 而在react中, 组件原本就是js函数, 理论上比angular中异步加载组件简单得多. 然而复杂的地方在于与webpack的结合. 首先, 在ES6中, import是导入export模块的语法, import()可以用作动态导入模块, 但是webpack在使用import()时, 底层调用的是require, 所以需要在模块底下加上require的导出语法. 1234567const Demo = () =&gt; ( &lt;div&gt; &lt;span&gt;Demo!&lt;/span&gt; &lt;/div&gt;);module.exports = Demo; //这个是动态模块需要加上的export default Demo; 然后是, webpack对动态模块的支持性. 当直接在import()中给定url时, webpack会在编译时分析所加载文件, 并将其打包为单独的文件. 如果url为动态内容或者是从后台获取到的内容, 那么就会存在问题. 查webpack官方文档时, 可以看到它是支持动态模块的, 但是语法和例子都没写清楚. 不过后来在网上查资料时, 看到了Sean Larkin(webpack Maintainer)在知乎上的一个回答, 所以解决了这个问题. 1const getTemplate = (templateName, templatePath) =&gt; import(`../../../../project-template/pc/${templatePath)/js/common/${templateName}.html`) 简单理解就是, 当在webpack中使用动态导入时, 需要给定partial path, 这样webpack才能找到你所需的模块. 以上两个问题解决以后, 实现一个异步加载的组件就比较简单了. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import React from 'react';import { PropTypes as P } from 'prop-types';import Loading from './../loading';class AsyncComponent extends React.PureComponent { static propTypes = { src: P.string.isRequired, loadingStart: P.func, loadingEnd: P.func, }; static defaultProps = { loadingStart: () =&gt; {}, loadingEnd: () =&gt; {}, }; constructor(props) { super(props); if (!props.src) { throw 'AsyncComponent need src'; } this.state = { component: null, }; } getComponentFromFileAsync(src) { this.props.loadingStart(); import(`./../../_container/${src}.js`).then((v) =&gt; { if (!this._isMounted) return; this.props.loadingEnd(); this.setState({ component: v, }); }); } componentDidMount() { this._isMounted = true; this.getComponentFromFileAsync(this.props.src); } componentWillReceiveProps(nextProps, nextState) { if (nextProps.src != this.props.src) { this.getComponentFromFileAsync(nextProps.src); } } componentWillUnmount() { this._isMounted = false; } render() { let Com = this.state.component; if (!Com) { return &lt;Loading /&gt;; } else { return &lt;Com {...this.props} src={undefined} /&gt;; } }}export default AsyncComponent; 推荐配合router一起使用, 也可做动态配置的权限控制, 使用方法 : 12345678910111213&lt;Switch&gt; {this.state.routeList.map((item, index) =&gt; { if (item.get('to')) { return &lt;Redirect key={index} path={item.get('url')} exact={item.get('exact')} to={item.get('to')} /&gt;; } else if (item.get('src')) { return &lt;Route key={index} path={item.get('url')} exact={item.get('exact')} render={() =&gt; &lt;AsyncComponent src={item.get('src')} /&gt;} /&gt;; } else { return null; } })} &lt;Route exact path='/' render={() =&gt; '欢迎来到首页'} /&gt; &lt;Redirect path='*' to='/' /&gt;&lt;/Switch&gt;","link":"/2017/2017-10-13-react-async-component/"},{"title":"react redux-form 使用","text":"react中的表单验证, 输入限制等功能并不完善, 好在有redux-form库来提供比较方便的复杂表单实现功能. 注册reducer1234567import { combineReducers } from 'redux-immutable';import { reducer as formReducer } from 'redux-form/immutable';let _reducer = {};_reducer['form'] = formReducer;const RootReducer = combineReducers(_reducer); 实现常用的带验证输入框1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//TextField.jsimport React from 'react';import classNames from 'classnames';import { NgCmd, } from './../../_component';const TextField = ({ input, label, labelClassName, inputDivClassName, className, type, maxLength, row, meta: { touched, error, warning },}) =&gt; ( &lt;div className={classNames(className, 'has-feedback', { 'has-error': touched &amp;&amp; error, 'has-warning': touched &amp;&amp; !error &amp;&amp; warning, 'has-success': touched &amp;&amp; !error &amp;&amp; !warning, })}&gt; &lt;label className={classNames('control-label', labelClassName)}&gt;{label}&lt;/label&gt; &lt;div className={classNames(inputDivClassName, { 'hint--bottom-right hint-error': touched &amp;&amp; error, 'hint--bottom-right hint-warning': touched &amp;&amp; !error &amp;&amp; warning, })} aria-label={error || warning}&gt; &lt;NgCmd if={!row}&gt; &lt;input className=&quot;form-control&quot; type={type || 'text'} maxLength={maxLength} {...input} /&gt; &lt;/NgCmd&gt; &lt;NgCmd if={!!row}&gt; &lt;textarea className=&quot;form-control&quot; row={row} maxLength={maxLength} {...input} /&gt; &lt;/NgCmd&gt; &lt;span className={classNames('glyphicon form-control-feedback', { 'glyphicon-remove': touched &amp;&amp; error, 'glyphicon-warning-sign': touched &amp;&amp; !error &amp;&amp; warning, 'glyphicon-ok': touched &amp;&amp; !error &amp;&amp; !warning, })} /&gt; &lt;/div&gt; &lt;/div&gt; )export default TextField;//DateTimePickerField.jsimport React from 'react';import classNames from 'classnames';import { DateTimePicker, } from './../../_component';const DateTimePickerField = ({ input, label, labelClassName, inputDivClassName, className, meta: { touched, error, warning }, ...rest, }) =&gt; ( &lt;div className={classNames(className, 'has-feedback date-time-picker', { 'has-error': touched &amp;&amp; error, 'has-warning': touched &amp;&amp; !error &amp;&amp; warning, 'has-success': touched &amp;&amp; !error &amp;&amp; !warning, })}&gt; &lt;label className={classNames('control-label', labelClassName)}&gt;{label}&lt;/label&gt; &lt;div className={classNames(inputDivClassName, { 'hint--bottom-right hint-error': touched &amp;&amp; error, 'hint--bottom-right hint-warning': touched &amp;&amp; !error &amp;&amp; warning, })} aria-label={error || warning}&gt; &lt;DateTimePicker {...input} {...rest} /&gt; &lt;span className={classNames('glyphicon form-control-feedback', { 'glyphicon-remove': touched &amp;&amp; error, 'glyphicon-warning-sign': touched &amp;&amp; !error &amp;&amp; warning, 'glyphicon-ok': touched &amp;&amp; !error &amp;&amp; !warning, })} /&gt; &lt;/div&gt; &lt;/div&gt; )export default DateTimePickerField; 定义Form组件内容1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162const ImmutableForm = reduxForm({ form: personToDoItemFormName,})((props) =&gt; { const { handleSubmit, pristine, reset, submitting, submit } = props; return ( &lt;form onSubmit={handleSubmit} className='form-horizontal'&gt; &lt;div className='form-group'&gt; &lt;Field name='ItemName' type='text' component={TextField} label='事项名称' maxLength='50' validate={validateHelper({ required: true, tips: '事项名称必填', validates: 'validName' })} warn={validateHelper({ minLength: 5, tips: '建议名称不少于5个字符' })} labelClassName='col-sm-2' inputDivClassName='col-sm-10' /&gt; &lt;/div&gt; &lt;div className='form-group'&gt; &lt;Field name='ItemContent' row='3' type='text' component={TextField} label='事项内容' maxLength='500' validate={validateHelper({ required: true, tips: '事项内容必填', maxLength: 500 })} warn={validateHelper({ minLength: 5, tips: '建议内容不少于5个字符' })} labelClassName='col-sm-2' inputDivClassName='col-sm-10' /&gt; &lt;/div&gt; &lt;div className='form-group'&gt; &lt;Field name='ItemRemark' row='3' type='text' component={TextField} label='备注' maxLength='500' validate={validateHelper({ tips: '备注不能超过500字符', maxLength: 500 })} labelClassName='col-sm-2' inputDivClassName='col-sm-10' /&gt; &lt;/div&gt; &lt;div className='form-group'&gt; &lt;Field name='CompleteTime' component={DateTimePickerField} label='完成时间' dateTimeformat={props.dateTimeformat} dateTimestartDate={new Date().Format('yyyy-MM-dd hh:mm')} dateTimeminView='0' validate={validateHelper({ tips: '必须为日期格式', regex: /^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}$/ })} labelClassName='col-sm-2' inputDivClassName='col-sm-10' /&gt; &lt;/div&gt; &lt;/form&gt; );}); 使用Form组件和表单事件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const mapDispatchToProps = (dispatch) =&gt; ({ fn: { openNewWindow: (windowParam) =&gt; { dispatch(PopupWindowListAction.openNewWindow(windowParam)); }, alertMsg: (windowParam) =&gt; { dispatch(PopupWindowListAction.alertMsg(windowParam)); }, closeWindow: (windowId) =&gt; { dispatch(PopupWindowListAction.closeWindow({ windowId })); }, getInitItemInfo: () =&gt; { dispatch(Action.getInitItemInfo()); }, getItemInfo: (id) =&gt; { dispatch(Action.getItemInfo(id)); }, initialize: (values, keepDirty) =&gt; { dispatch(initialize(formName, values, keepDirty)); }, submit: () =&gt; { dispatch(submit(formName)); }, touch: () =&gt; { dispatch(touch(formName)); }, saveOrUpdateItem: (info) =&gt; { dispatch(Action.saveOrUpdateItem(info)); }, },});clickSave() { this.props.fn.touch(); if (this.props.formState.get('syncErrors')) { let err = ''; _.forIn(this.props.formState.get('syncErrors'), function (value, key) { err += value + '&lt;br /&gt;'; }); this.props.fn.alertMsg(`表单未填写完成:&lt;br /&gt;${err}`); } else { this.props.fn.saveOrUpdateItem(this.props.formState.get('values').toJS()); }}//render&lt;span className=&quot;btn btn-success btn-text&quot; onClick={this.clickSave}&gt;保存&lt;/span&gt;&lt;ImmutableForm /&gt; 附validateHelpervalidateHelper是自己实现的一个简单的验证生成器, 支持缓存验证器, 多种内置验证器, 多个验证器, 自定义错误提示, 自定义正则验证即提示等功能. 具体使用方法可以看上面的例子. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import Immutable from 'immutable';import _ from 'lodash';let validateHelpers = Immutable.Map();const defaultValidates = { validCode: { test: /^[a-zA-Z_][a-zA-Z0-9._-]{1,49}$/i, tips: `格式应该为code`, }, validName: { test: (v) =&gt; v.length &gt;= 2 &amp;&amp; v.length &lt;= 50, tips: `格式应该为name`, }, validMoney: { test: /(^[1-9][0-9]{0,5}(\\.[0-9]{1,4})?$)|(^(0){1}$)|(^[0-9]\\.[0-9]([0-9]){0,3}$)/i, tips: `格式应该为money`, },};function validateHelper(options = {}) { const { required, maxLength, minLength, regex, tips, validates } = options; const key = Immutable.fromJS({ required, maxLength, minLength, regex, tips, validates, }); if (validateHelpers.has(key)) { return validateHelpers.get(key); } else { const fun = function (value, allValues, props, name) { const valueStr = _.toString(value); if (required &amp;&amp; _.isEmpty(valueStr)) { let defaultTips = '该字段必填'; return tips ? (_.isString(tips) ? tips : tips['required'] || tips.default || defaultTips) : defaultTips; } if (minLength &amp;&amp; valueStr.length &lt; minLength) { let defaultTips = `该字段最小长度为${minLength}`; return tips ? (_.isString(tips) ? tips : tips['minLength'] || tips.default || defaultTips) : defaultTips; } if (maxLength &amp;&amp; valueStr.length &gt; maxLength) { let defaultTips = `该字段最大长度为${maxLength}`; return tips ? (_.isString(tips) ? tips : tips['maxLength'] || tips.default || defaultTips) : defaultTips; } if (regex &amp;&amp; !regex.test(value)) { let defaultTips = `该字段格式不对`; return tips ? (_.isString(tips) ? tips : tips['regex'] || tips.default || defaultTips) : defaultTips; } let validatesArr = _.isString(validates) ? [validates] : validates || []; for (let i = 0; i &lt; validatesArr.length; i++) { var valid = defaultValidates[validatesArr[i]]; if (valid) { if (_.isFunction(valid.test) &amp;&amp; !valid.test(valueStr)) { return tips ? (_.isString(tips) ? tips : tips.default || valid.tips) : valid.tips; } else if (_.isFunction(valid.test.test) &amp;&amp; !valid.test.test(valueStr)) { return tips ? (_.isString(tips) ? tips : tips.default || valid.tips) : valid.tips; } } else { throw `${validatesArr[i]}未找到`; } } }; validateHelpers = validateHelpers.set(key, fun); return fun; }}export default validateHelper;","link":"/2017/2017-10-23-react-redux-form/"},{"title":"react redux-form 中异步提交文件","text":"在之前看redux-form的时候, 只实现了两种比较简单的Field组件, TextField和DateTimeField, 现在来看看一个麻烦一点的FileField. 文件上传是比较常用的功能, 尽量做到简单易用的组件化形式为好, 首先定义FileField组件. 1234567891011121314151617181920212223242526272829303132333435363738394041class FileField extends React.PureComponent { static propTypes = {}; render() { let { input, label, inputFile, labelClassName, inputDivClassName, className, inputClassName, meta: { touched, error, warning }, } = this.props; return ( &lt;div className={classNames(className, 'has-feedback', { 'has-error': touched &amp;&amp; error, 'has-warning': touched &amp;&amp; !error &amp;&amp; warning, 'has-success': touched &amp;&amp; !error &amp;&amp; !warning, })} &gt; &lt;label className={classNames('control-label', labelClassName)}&gt;{label}&lt;/label&gt; &lt;div className={classNames(inputDivClassName, { 'hint--bottom-right hint-error': touched &amp;&amp; error, 'hint--bottom-right hint-warning': touched &amp;&amp; !error &amp;&amp; warning, })} aria-label={error || warning} &gt; &lt;div className='input-group cursor-p'&gt; &lt;input type='text' readOnly className={classNames('form-control cursor-p', inputClassName)} {...input} /&gt; &lt;span className='input-group-addon'&gt; &lt;span className='glyphicon glyphicon-file'&gt;&lt;/span&gt; &lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;input ref='selectFileInput' type='file' className='hide' {...inputFile} /&gt; &lt;/div&gt; ); }} 然后给组件加入点击事件和触发打开弹窗的事件. 123456789101112131415161718192021222324252627282930313233&lt;div className=&quot;input-group cursor-p&quot; onClick={this.clickOpenSelectFileWindow}&gt;&lt;input ref=&quot;selectFileInput&quot; type=&quot;file&quot; className=&quot;hide&quot; onChange={this.clickSelectFileChange} {...inputFile} /&gt;const mapDispatchToProps = (dispatch) =&gt; ({ fn: { change: (form, field, value) =&gt; { dispatch(change(form, field, value)); }, },});@connect(null, mapDispatchToProps)class FileField extends React.PureComponent { constructor(props) { super(props); this.state = {}; this.clickOpenSelectFileWindow = this.clickOpenSelectFileWindow.bind(this); this.clickSelectFileChange = this.clickSelectFileChange.bind(this); } clickOpenSelectFileWindow(event) { this.refs.selectFileInput.click(); if (event) { event.preventDefault(); event.stopPropagation(); } } clickSelectFileChange(event) { let fileName = event.target.files.length &gt; 0 ? event.target.files[0].name : ''; this.props.fn.change(this.props.formName, this.props.input.name, fileName); this.props.fn.change(this.props.formName, this.props.input.name + 'Files', event.target.files); }}//使用&lt;Field name=&quot;SelectFile&quot; component={FileField} label=&quot;选择文件&quot; labelClassName=&quot;col-sm-2&quot; inputDivClassName=&quot;col-sm-10&quot; formName={toDoItemFormName} /&gt; 这样基本实现了点击输入框, 会弹出选择文件, 选择完成以后会显示选择文件的名字, 而选择到的文件保存在redux-form的state中同名field加后缀Files下. 在提交时只需要提取相应文件传入到后台即可. 这里使用jquery-form来实现异步提交文件. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970var postFile = function (data, files) { var $form = $('&lt;form&gt;&lt;input name=&quot;CommandName&quot; value=&quot;' + data.CommandName + '&quot;/&gt;&lt;/form&gt;'); var $newInput = $('&lt;input name=&quot;myFile&quot; type=&quot;file&quot;/&gt;'); $newInput[0].files = files; $form.append($newInput); var params = _.isString(data.params) ? data.params : JSON.stringify(data.params); $form.append($('&lt;input type=&quot;text&quot; name=&quot;data&quot; value=&quot;' + encodeURIComponent(params) + '&quot;/&gt;')); var promise = new Promise((resolve, reject) =&gt; { $form.ajaxSubmit({ url: url, type: &quot;POST&quot;, dataType: &quot;json&quot;, success: function (resultValue) { let action = resolveResultValue(resultValue); if (action.action === ActionType.SUCCESS) { return resolve(resultValue); } else { return reject(action); } }, error: function (resultValue) { return reject({ action: ActionType.NETWORK_ERROR, payload: resultValue.responseText }); }, }); }).then((resultValue) =&gt; { ...//log return resultValue.returnValue; }).catch(({ action, payload }) =&gt; { ...//异常处理 return Promise.reject(payload); }) return promise;}//service.jssaveOrUpdateItemWithFile: (info) =&gt; { return commonAjaxService.postFile({ CommandName: 'Service$SaveOrUpdateInfoWithFiles', params: info, }, info.SelectFileFiles);},//action.jsstatic saveOrUpdateItemWithFile(info) { return (dipatch, getState) =&gt; { let action = { type: ActionType.SAVE_ITEM_START, payload: null, }; dipatch(action); dipatch(startSubmit(toDoItemFormName)); return Service.saveOrUpdateItemWithFile(info).then( (resultValue) =&gt; { dipatch(setSubmitSucceeded(toDoItemFormName)); let action = { type: ActionType.SAVE_ITEM_END, payload: resultValue, }; dipatch(action); }, (error) =&gt; { dipatch(setSubmitFailed(toDoItemFormName)); let action = { type: ActionType.SAVE_ITEM_END, payload: null, }; dipatch(action); } ); };} 还有个情况是, 想在别的地方触发该文件选择框. 那么提供一个传入函数, 在函数返回当前组件实例(类似 ref), 在需要触发的时候执行ref.clickOpenSelectFileWindow(event)即可. 1234567891011121314151617//file-field.jsstatic propTypes = { componentRef: P.func.isRequired,}componentDidMount() { if (this.props.componentRef) { this.props.componentRef(this); }}//使用bindInputFileRef(ref){ this.inputFileRef = ref;}targetOpenFileSelectWindow(event){ this.inputFileRef.clickOpenSelectFileWindow(event);}&lt;Field componentRef={bindInputFileRef} name=&quot;SelectFile&quot; component={FileField} label=&quot;选择文件&quot; labelClassName=&quot;col-sm-2&quot; inputDivClassName=&quot;col-sm-10&quot; formName={personToDoItemFormName} /&gt;","link":"/2017/2017-10-29-react-redux-form-post-file/"},{"title":"JavaScript 填坑之 flow 和 WebAssembly 技术","text":"js的坑作为一门只用了十天时间赶工出来的动态语言, JavaScript已经做得很好了, 但是有些不得不解决的问题也逐渐暴露出来了. 下面是一些坑列表. 运行性能, 由google的v8引擎解决. 类型继承, 由ES6语法糖和phototype对象构成原型链解决. 模块化, 由ES6的import和exports实现. 全局变量(window), 社区方案使用Global统一替换. 回调函数机制, 由promise解决. 动态语言导致的大型项目类型检查, 使用React.PropTypes和flowjs, 或者使用TypeScript. v8引擎编译性能, WebAssembly技术. flowjsflowjs是Facebook为了大型js项目拥有类型检查而发明的一个库. 使那些需要类型检查的项目不需要使用重量级的TypeScript的另一个解决方案. 基本作用是通过可选的类型声明, 在写代码时自动检查类型是否匹配. 语法也不会很麻烦, 基本都是在变量后面加上:type来声明. 但是我看了一圈, 好像没有解构赋值时的类型语法, 这样就有点麻烦了. 1234567891011121314/* @flow */function foo(x: ?number): string { if (x) { return x; } return &quot;default string&quot;;}//报错:5: return x; ^ number. This type is incompatible with the expected return type of3: function foo(x: ?number): string { ^ string v8引擎在说WebAssembly之前, 必须看看v8引擎的原理和不足. chrome现在这么高的市场占有率有一半都是靠着v8引擎的速度取得的. v8引擎底层由C++实现, 可以作为一个独立模块, 被任何C++应用引用. 如Node.js框架就是基于v8引擎. v8基本功能也是编译, 执行js代码, 管理内存, 负责垃圾回收, 与宿主语言交互等功能. 而这种运行时编译的语言都存在一个问题, 即类型改变. v8中编译技术为JIT(Just in time compiling), JIT基于运行期分析编译, 而JavaScript是一个没有类型的语言, 于是大部分时间, JIT编译器其实是在猜测JavaScript中的类型, 如开始一个函数执行的是add(1,1), 那么JIT会将它编译成add(int a,int b)来执行, 并保存, 但如果下次调用add('a','b'), 那么JIT则需要重新编译一遍. 在js这种动态类型的情况下, 一个函数会发生很多次编译, 重新编译开销又非常大, 这便是v8或者说js引擎无法避免的问题. Google也发明过声明, 认为js是一门天生残疾的语言, 然后就不再继续发力v8虚拟机了. v8其实已经事实上代表了js能达到的运行时性能顶峰, 而Google也认为基于这种动态类型无法再继续提升虚拟机性能了. asm.jsasm是mozilla提出的一个解决方案, 和js语法相同, 只是在火狐浏览器中会特别解析语法, 直接编译成机器语言, 极大的加快执行速度. 但是存在的一个问题是浏览器支持率并不高, 而且也不是官方解决方案. WebAssembly这时候, 几大浏览器厂家(Mozilla, Google, Microsoft, Apple)觉得这种思路还是可以的, 那么就升级一下, 变为WebAssembly技术. 这种技术基本等于浏览器执行原生代码. 和Java调用JNI一样的速度. start需要安装的内容有点多, 参考官方文档和所需工具. Emscripten Binaryen WABT (WebAssembly Binary Toolkit) 在非开发版的浏览器中, Firefox对WebAssembly支持比较好, 在浏览器控制台中粘贴以下代码, 如果可以运行而且不报错, 说明支持WebAssembly. 1234567891011121314151617181920WebAssembly.compile(new Uint8Array(` 00 61 73 6d 01 00 00 00 01 0c 02 60 02 7f 7f 01 7f 60 01 7f 01 7f 03 03 02 00 01 07 10 02 03 61 64 64 00 00 06 73 71 75 61 72 65 00 01 0a 13 02 08 00 20 00 20 01 6a 0f 0b 08 00 20 00 20 00 6c 0f 0b`.trim().split(/[\\s\\r\\n]+/g).map(str =&gt; parseInt(str, 16)))).then(module =&gt; { const instance = new WebAssembly.Instance(module) const { add, square } = instance.exports console.log('2 + 4 =', add(2, 4)) console.log('3^2 =', square(3)) console.log('(2 + 5)^2 =', square(add(2 + 5)))})//运行结果Promise { &lt;state&gt;: &quot;pending&quot; }2 + 4 = 63^2 = 9(2 + 5)^2 = 49 WebAssembly有明确的数据类型, 上面函数运行时传入参数应该为int 32类型, 不过如果传其他值会被动态转换, 所以add('2',3) = 5, add('2',{a:1}) = 2. 但是不推荐这样使用, 因为具体会转换成什么不能确定, 通常是0. 编译C/C++到WebAssembly使用WebAssembly技术, 肯定不能直接写二进制代码, 否则为什么要用js. WebAssembly一般都是由其他语言编译过来, 如C/C++等. 网上有个在线工具可以查看WasmExplorer, 生成的wast文件可以转换成wasm文件并下载下来. 先写一段C代码, 然后执行emcc demo.c -Os -s WASM=1 -s SIDE_MODULE=1 -o demo.wasm, 即可生成wasm文件. 执行wasm文件执行wasm目前只有一种方法, 即通过javascript. 官网文档里也有提供初略的例子. 123456789101112131415161718192021222324252627//demo.cint addThree(int a, int b, int c){ return a + b + c;}//index.htmlfunction loadWebAssembly(filename, imports = {}) { return fetch(filename) .then(response =&gt; response.arrayBuffer()) .then(buffer =&gt; WebAssembly.compile(buffer)) .then(module =&gt; { imports.env = imports.env || {} Object.assign(imports.env, { memoryBase: 0, tableBase: 0, memory: new WebAssembly.Memory({ initial: 256, maximum: 256 }), table: new WebAssembly.Table({ initial: 0, maximum: 0, element: 'anyfunc' }) }) return new WebAssembly.Instance(module, imports) })}loadWebAssembly('/demo.wasm') .then(instance =&gt; { const addThree = instance.exports._addThree console.log('1 + 2 + 3 =', addThree(1, 2, 3)) }) asm.js编译成WebAssemblyasm.js既然是带类型的js, 那么也可以生成WebAssembly文件. 官方有提供工具Binaryen和WABT (WebAssembly Binary Toolkit). 流程基本是由js生成wast文件, 再转换成wasm文件. WebAssembly调用JavaScript目前来说, 调用方法还是比较麻烦的, 需要将调用的函数通过imports参数传入模块中, 而且需要在wast文件中, 添加import和调用call方法才可以执行. 期待以后简单点的写法互相调用, 那么就可以实现任何语言来写js代码了, 而且运行速度将大大加快.","link":"/2017/2017-11-16-flowjs-and-webassembly/"},{"title":"量子计算原理入门","text":"最近 IBM 出了一款 50bit 的量子计算机. 于是好奇的去学了下量子计算原理. 在经典计算机中, 用高电平表示1, 低电平表示0, 使用与, 或, 非三种门来实现对二进制位的基本操作, 比如计算1+1等. 这样的计算结果能保证准确可靠, 不过由于电流是’单线程’的, 那么在多次计算的时候, 便只能不停的循环计算. 比如需要计算1+1, 再计算2+2, 计算机只能先计算出一个结果, 再去计算另一个. 在量子计算机中, 这一切都不同了. 首先量子计算机在运行时没有准确的1和0状态. 就像’薛定谔的猫’一样, 只有在观测的时候才能准确的知道该量子状态是1还是0. 那么使用量子计算机的时候, 便可以假设所有位都是1和0的混合状态. 如果对某一位进行操作, 那么会同时对1和0两种状态进行操作, 生成两种结果, 但是该结果在观测的时候是随机的由1或0生成的结果, 各自比例为50%. 如果对多位进行同时操作, 那么会对它们都造成影响, 生成的结果有2^n个, 观测时候结果为某一位, 概率为1/2^n. 到这一步了以后可能就觉得量子计算不就是坑爹的嘛, 全凭计算出的运气随机观测结果, 结果到底是不是对的也不知道, 就如进行1+1, 可能的结果为: 0,1,1,2. 这时候算法大神们就出场了. Grover算法为一个对数据库进行随机搜索的量子算法. 在传统计算机和数据库中, 如果需要根据某个条件查找一条数据(非主键和索引)时, 需要从头到尾一条条数据循环查找, 这样的计算复杂度为O(N). 而在量子计算机中, 可以将所有数据导入到量子比特中, 只需要占用log2(N)个量子比特, 然后同时对该条件求值, 那么会生成N个计算结果, 而且必有 1 个结果为正确结果, 但是每个结果发生的概率均为1/N. Grover算法思想是, 同时计算出这么多结果以后, 先不要去读取结果, 即不’观测’, 先通过量子操作, 增加正确结果发生的概率. 在一系列复杂的量子操作以后, 该概率会增加一点, 在进行π * √N / 4次操作以后, 要找到的那个数据的发生概率会达到最大, 最大值为1 - 1/2^N. 这时候再去读取数据, 就会以极大的概率读取到正确的数据. 该搜索算法在量子计算机中, 可以将普通搜索的O(N)复杂度变为O(√N), 但是不足之处在于成功读取正确数据的概率永远都不是100%, 所以并不能算完美. 其他使用量子计算机的算法原理也基本类似, 所以都不可能达到完美的结果. 那么量子计算的应用领域也比较清晰了, 适合大量并行任务进行的场景, 如’猜密码’等. 而且需要特殊设计算法, 用于对所有结果进行计算而且选出正确结果的特殊算法. 参考:Grover 算法实现","link":"/2017/2017-12-25-quantum-computing/"},{"title":"xposed 插件开发","text":"换了新手机，装上了Xposed加上各种插件，简直完美。以前一直想了解Xposed是如何工作的，正好有个插件有点 Bug，于是了解一下。 首先看文档，安装好Android Studio，下载开发包，导入项目，修改好gradle里的配置，这些网上都有直接的教程，没有很大问题。然后在AndroidMenafest.xml文件里声明为Xposed模块，创建Hook类，并创建xposed_init文件，声明好入口。 1234567@Overridepublic void handleLoadPackage(final XC_LoadPackage.LoadPackageParam lpparam) throws Throwable { if (!PackageList.contains(lpparam.packageName)) { return; } XposedBridge.log(String.format(&quot;Hello xposed!&quot;));} 安装运行代码以后，可以在Xposed里找到刚刚安装的 APP，勾上并开启，重启手机便能看到在Xposed日志里打印的Hello xposed!了。 开发Xposed比较麻烦的地方在于每次改代码以后安装都需要重启，而且调试其他APP只能通过日志查看，于是我找到了可以使用Android Studio断点调试功能的方法。首先需要建一个自己的APP，调用会触发Xposed的代码，在Android Studio里面运行附加调试，调试的内容是调试Xposed插件的代码而不是那个APP，这样在APP中触发了Xposed应用代码以后，断点即可进入了。 剩下的内容便很简单了，找到原来那个插件的代码，发现它的调用方式有问题，去查看Android源码，找到正确的调用方式，使用反射拿到对象并调用，于是便解决了问题。唯一的麻烦就是查Android源码需要将各个版本的都下载下来并查看，而国内的网速… 有了这个插件以后，之前的那个有问题的插件也不用安装了，直接卸载，用这个替代，为了解决之前插件的一些缺陷，还准备做个可视化界面，目前只是把数据写入数据库，可以使用sqlite editor查看。 还有个情况是，好像在初始化的时候不能读取数据库和文件，于是做不到动态判断哪些包是需要拦截哪些不需要。可能底层 C 语言可以做到，但是太麻烦了，以后如果还涉及到这种插件可以研究下动态加载拦截包如何实现。 这个插件如果有需要也可以自由下载代码编译，个人比较懒，也不想发布到Xposed市场里。","link":"/2018/2018-03-12-xposed-sport-editod/"},{"title":"react-native 入门","text":"上次的Xposed插件少个可视化界面，如果直接使用Android开发也不是不行，但是那样太无聊了，正好试试一直想使用的React Native技术来开发一个简单的界面。 开发工具同样是简单的Android Studio，按照RN中文网上的开发步骤先搭建一个Hello World，基于这个demo先做一个不读取数据的展示页面，顺便学习一下导航栏的使用。 RN 与原生的数据交互是通过NativeModules这个对象进行异步操作的，可以通过async和await使操作更简单，并封装一个调用原生的方法 12345import { NativeModules } from 'react-native';export async function JsDBHelperCall(func, ...args) { return await NativeModules.JsDBHelper[func](...args);} 简单的应用里也无需使用redux来管理数据，直接使用Props传递即可，其他的代码基本和写React一样，然后运行起来并写好java端的代码，实现数据流通便算完成。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class JsDBHelper extends ReactContextBaseJavaModule { private DBHelper db = null; private SportEditorDao sportEditorDao = null; public JsDBHelper(ReactApplicationContext reactContext) { super(reactContext); db = new DBHelper(reactContext); sportEditorDao = new SportEditorDao(reactContext); } @Override public String getName() { return this.getClass().getSimpleName(); } @ReactMethod public void ExecSQL(String sql, ReadableArray selectionArgs) { try { JSONArray args = ArrayUtil.toJSONArray(selectionArgs); db.ExecSQL(sql, args.toJavaList(String.class)); } catch (JSONException e) { e.printStackTrace(); } } @ReactMethod public void QueryForMap(String sql, ReadableArray selectionArgs) { try { JSONArray args = ArrayUtil.toJSONArray(selectionArgs); Map&lt;String, String&gt; result = db.QueryForMap(sql, args.toJavaList(String.class)); } catch (JSONException e) { e.printStackTrace(); } } @ReactMethod public void QueryForListMap(String sql, ReadableArray selectionArgs, Promise promise) { ... } @ReactMethod public void GetConfigByPackageName(String packageName, Promise promise) { ... } @ReactMethod public void GetConfigs(Promise promise) { ... } @ReactMethod public void SaveConfig(ReadableMap selectionArgs, Promise promise) { ... }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253export default class HomeScreen extends React.PureComponent { constructor(props) { super(props); this.state = { configs: Immutable.fromJS([]), refreshing: false, isLoading: true, }; this.onRefresh = this.onRefresh.bind(this); this.rowClick = this.rowClick.bind(this); } async componentDidMount() { let configs = await JsDBHelperCall('GetConfigs'); this.setState({ isLoading: false, configs: Immutable.fromJS(configs), }); console.log(configs); } async onRefresh() { this.setState({ refreshing: true, }); let configs = await JsDBHelperCall('GetConfigs'); this.setState({ refreshing: false, configs: Immutable.fromJS(configs), }); console.log(configs); } rowClick(config, index) { this.props.navigation.navigate('Detail', { config: config, callBack: this.onRefresh, }); } render() { const emptyText = this.state.isLoading ? 'Loading...' : this.state.errorMsg ? 'Error!' : 'No data.'; return ( &lt;View&gt; &lt;ImmutableVirtualizedList immutableData={this.state.configs} keyExtractor={(item, index) =&gt; item.get('packageName')} ListHeaderComponent={() =&gt; &lt;AppRowHeader /&gt;} renderItem={({ item, index }) =&gt; &lt;AppRow config={item} rowClick={this.rowClick} index={index} /&gt;} onRefresh={this.onRefresh} refreshing={this.state.refreshing} renderEmptyInList={emptyText} /&gt; &lt;/View&gt; ); }} 然后再将原来的Xposed APP代码原样移植到这边的java层，丢到手机运行，收工！ 这个插件如果有需要也可以自由下载代码编译，个人比较懒，也不想发布到Xposed市场里。","link":"/2018/2018-06-05-react-native-start/"},{"title":"微信跳一跳自动辅助","text":"最近微信跳一跳在元旦一周火了起来, 刚玩的时候能艰难的跳到120+分, 看了网上的站立加分能跳到280+. 使用GGuardian让每次踩中心能加32分能跳到接近1000, 然而每次重开太累了, 于是抽晚上和周末写了个自动跳. 目前最高分有4000+, 不过是因为要玩手机而手动停止, 并不是算法问题. 想直接使用的看这里 思路 手机截图发送到电脑 电脑读取图片像素, 分析图片, 得到跳跃距离 根据跳跃距离和计算函数得出按压时间 发送按压时间到手机长按 -&gt; 跳! 再次截图, 并循环 手机截图还好使用的是android, 可以直接使用adb shell进行截图, 并发送到电脑. 百度一下可以得到以下几个命令. 1234//调用截图, 并将截图保存到/sdcard/screenshot.pngadb shell /system/bin/screencap -p /sdcard/screenshot.png//将截图从手机复制到电脑目录adb pull /sdcard/screenshot.png d:/screenshot.png 然后再带一个删除图片的linux命令, 免得截图太多浪费内存空间. 1adb shell rm /sdcard/screenshot.png 按压命令顺便查了一下发送输入事件到手机的命令, 也挺简单的. 1234//点击x,y坐标adb shell input tap x y//使用n毫秒从(x1,y1)滑动到(x2,y2), 模拟长按事件adb shell input swipe 500 500 501 501 2000 测试了一下, 发现一般距离按个300ms-400ms, 基本都能跳到. 算测试成功, 进行下一步. 开始帮助类库首先还是使用.Net + C#, 毕竟window平台下最好用的语言. 图片的读取和写入还是使用之前读取支付宝 AR 红包时候用的Byte[]和System.Runtime.InteropServices.Marshal, 性能远远优于.Net自带的图片像素颜色读取写入. 方法也类似之前的方法, 只是数组改成二维数组了, 方便一些, 由于有半透明图片的读取, 所以还添加了一个读取RGBA值的方法. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116public static void GetRGB(this Bitmap image, int startX, int startY, int w, int h, int[][] rgbArray){ const int PixelWidth = 3; const PixelFormat PixelFormat = PixelFormat.Format24bppRgb; // En garde! if (image == null) throw new ArgumentNullException(&quot;image&quot;); if (rgbArray == null) throw new ArgumentNullException(&quot;rgbArray&quot;); if (startX &lt; 0 || startX + w &gt; image.Width) throw new ArgumentOutOfRangeException(&quot;startX&quot;); if (startY &lt; 0 || startY + h &gt; image.Height) throw new ArgumentOutOfRangeException(&quot;startY&quot;); if (w &lt; 0 || w &gt; image.Width) throw new ArgumentOutOfRangeException(&quot;w&quot;); if (h &lt; 0 || (rgbArray.Length &lt; h) || h &gt; image.Height) throw new ArgumentOutOfRangeException(&quot;h&quot;); BitmapData data = image.LockBits(new Rectangle(startX, startY, w, h), System.Drawing.Imaging.ImageLockMode.ReadOnly, PixelFormat); try { byte[] pixelData = new Byte[data.Stride]; for (int i = 0; i &lt; h; i++) { rgbArray[i] = new int[w]; Marshal.Copy(data.Scan0 + (i * data.Stride), pixelData, 0, data.Stride); for (int j = 0; j &lt; w; j++) { // PixelFormat.Format32bppRgb means the data is stored // in memory as BGR. We want RGB, so we must do some // bit-shuffling. rgbArray[i][j] = (pixelData[j * PixelWidth + 2] &lt;&lt; 16) + // R (pixelData[j * PixelWidth + 1] &lt;&lt; 8) + // G pixelData[j * PixelWidth]; // B } } } finally { image.UnlockBits(data); }}public static void GetRGBA(this Bitmap image, int startX, int startY, int w, int h, long[][] rgbArray){ const int PixelWidth = 4; const PixelFormat PixelFormat = PixelFormat.Format32bppArgb; // En garde! if (image == null) throw new ArgumentNullException(&quot;image&quot;); if (rgbArray == null) throw new ArgumentNullException(&quot;rgbArray&quot;); if (startX &lt; 0 || startX + w &gt; image.Width) throw new ArgumentOutOfRangeException(&quot;startX&quot;); if (startY &lt; 0 || startY + h &gt; image.Height) throw new ArgumentOutOfRangeException(&quot;startY&quot;); if (w &lt; 0 || w &gt; image.Width) throw new ArgumentOutOfRangeException(&quot;w&quot;); if (h &lt; 0 || (rgbArray.Length &lt; h) || h &gt; image.Height) throw new ArgumentOutOfRangeException(&quot;h&quot;); BitmapData data = image.LockBits(new Rectangle(startX, startY, w, h), System.Drawing.Imaging.ImageLockMode.ReadOnly, PixelFormat); try { byte[] pixelData = new Byte[data.Stride]; for (int i = 0; i &lt; h; i++) { rgbArray[i] = new long[w]; Marshal.Copy(data.Scan0 + (i * data.Stride), pixelData, 0, data.Stride); for (int j = 0; j &lt; w; j++) { // PixelFormat.Format32bppARgb means the data is stored // in memory as BGRA. We want ARGB, so we must do some // bit-shuffling. rgbArray[i][j] = (((long)pixelData[j * PixelWidth + 3]) &lt;&lt; 24) + // A (pixelData[j * PixelWidth + 2] &lt;&lt; 16) + // R (pixelData[j * PixelWidth + 1] &lt;&lt; 8) + // G pixelData[j * PixelWidth]; // B } } } finally { image.UnlockBits(data); }}public static void SetRGB(this Bitmap image, int startX, int startY, int w, int h, int[][] rgbArray){ const int PixelWidth = 3; const PixelFormat PixelFormat = PixelFormat.Format24bppRgb; // En garde! if (image == null) throw new ArgumentNullException(&quot;image&quot;); if (rgbArray == null) throw new ArgumentNullException(&quot;rgbArray&quot;); if (startX &lt; 0 || startX + w &gt; image.Width) throw new ArgumentOutOfRangeException(&quot;startX&quot;); if (startY &lt; 0 || startY + h &gt; image.Height) throw new ArgumentOutOfRangeException(&quot;startY&quot;); if (w &lt; 0 || w &gt; image.Width) throw new ArgumentOutOfRangeException(&quot;w&quot;); if (h &lt; 0 || (rgbArray.Length &lt; h) || h &gt; image.Height) throw new ArgumentOutOfRangeException(&quot;h&quot;); BitmapData data = image.LockBits(new Rectangle(startX, startY, w, h), System.Drawing.Imaging.ImageLockMode.WriteOnly, PixelFormat); try { int dst_bytes = data.Stride * h; byte[] dstValues = new byte[dst_bytes]; IntPtr dstPtr = data.Scan0; Marshal.Copy(dstPtr, dstValues, 0, dst_bytes); int position = 0; for (int i = 0; i &lt; h; i++) { for (int j = 0; j &lt; w; j++) { position = (i * data.Stride) + j * PixelWidth; dstValues[position + 0] = (byte)(rgbArray[i][j]); dstValues[position + 1] = (byte)(rgbArray[i][j] &gt;&gt; 8); dstValues[position + 2] = (byte)(rgbArray[i][j] &gt;&gt; 16); } } Marshal.Copy(dstValues, 0, dstPtr, dst_bytes); } finally { image.UnlockBits(data); }} 开始的想法是, 从左上往右下扫描图片, 当碰到顶点的时候, 就能确定该顶点是目标物体, 然后根据顶点颜色找到整个目标面, 计算下平均坐标, 即可得到目标点.而自己的坐标确认方法, 看了一下好像自己的颜色不会变化, 那么就去PS里面, 把自己的棋子单独截出来, 当作Res资源图片, 在扫描时候碰见自己棋子颜色的时候, 就去和资源图片比对, 如果相关像素点颜色都一样, 那么就可以确定该点为自己的棋子, 再根据起点坐标和资源图片计算偏移, 即可得到自己的准确坐标. 那么就开始干活. 首先定义一个结构struct记录点的颜色, 为什么不是class而是struct呢, 因为性能好一些, 而且不会有引用值类型传错的可能. .Net还有个好处就是和C一样, 能重载+, ‘-‘, ‘*‘, ‘/‘, ‘==’这种运算符, 这样算法写起来也简单. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124public struct RGB{ public static char[] RGBNAME = new char[] { 'A', 'R', 'G', 'B' }; public RGB(long color, bool hasAlpha = false) { //this.R = color &gt;&gt; 16; //this.G = (color &amp; 65280) &gt;&gt; 8; //this.B = (color &amp; 255); this.A = hasAlpha ? (byte)(color &gt;&gt; 24) : 255; this.R = (byte)(color &gt;&gt; 16); this.G = (byte)(color &gt;&gt; 8); this.B = (byte)(color); } public static RGB FromInt(long color, bool hasAlpha = false) { return new RGB(color, hasAlpha); } public int ToInt() { return (this.R &lt;&lt; 16) + (this.G &lt;&lt; 8) + this.B; } public long ToLong(bool hasAlpha = false) { return (hasAlpha ? ((long)this.A) &lt;&lt; 24 : 0) + (this.R &lt;&lt; 16) + (this.G &lt;&lt; 8) + this.B; } public RGB(int r, int g, int b) { this.R = r; this.G = g; this.B = b; this.A = 255; } public RGB(int r, int g, int b, int a) { this.R = r; this.G = g; this.B = b; this.A = a; } public int Get(char key) { if (key &gt; 90) { key = (char)(key - 32); } switch (key) { case 'A': return this.A; case 'R': return this.R; case 'G': return this.G; case 'B': return this.B; } throw new ArgumentOutOfRangeException(&quot;字符不对&quot;); } public static RGB operator +(RGB color1, RGB color2) { return new RGB( color1.R + color2.R, color1.G + color2.G, color1.B + color2.B ); } public static RGB operator -(RGB color1, RGB color2) { return new RGB( color1.R - color2.R, color1.G - color2.G, color1.B - color2.B ); } public static RGB operator *(RGB color, int m) { return new RGB( color.R * m, color.G * m, color.B * m ); } public static RGB operator /(RGB color, int m) { return new RGB( color.R / m, color.G / m, color.B / m ); } public static RGB operator ~(RGB color) { return new RGB( 255 - color.R, 255 - color.G, 255 - color.B ); } public static bool operator ==(RGB color1, RGB color2) { return color1.A == color2.A &amp;&amp; color1.R == color2.R &amp;&amp; color1.G == color2.G &amp;&amp; color1.B == color2.B; } public static bool operator !=(RGB color1, RGB color2) { return !(color1 == color2); } public int R; public int G; public int B; public int A; public override string ToString() { return string.Format(&quot;R:{0},G:{1},B:{2},A:{3}&quot;, this.R, this.G, this.B, this.A); } public override bool Equals(object obj) { if (obj != null &amp;&amp; obj is RGB) { return this == (RGB)obj; } return base.Equals(obj); } public override int GetHashCode() { return this.ToLong(true).GetHashCode(); }} 有这个struct来帮助将颜色和bitmap里面存的int进行互相转换和计算以后, 就可以开始正式做图片识别相关的了, 目前还是使用的传统算法实现图片识别, 而不是网上比较多的人工智能Tensorflow + 训练集来识别图片. 两种算法各有优劣, 传统算法优势是意义明确, 可以清楚的知道代码是如何识别图片和如果失败哪里出现了问题, 人工智能识别的好处就是不用费心想算法…而且以后万一图片改了, 直接换个训练集一样能上能识别. 分析主函数先定义分析主函数double AnalyseSpace(), 主要流程是从图片中读取颜色信息, 然后分析图片, 计算出目标点坐标和自己点坐标, 根据位置求两点距离. 12345678910111213var bitmap = (Bitmap)Image.FromFile(ImgBoxResolved.ImageLocation);if (bitmap.Width != 1080 || bitmap.Height != 1920){ MessageBox.Show(&quot;图片错误&quot;); return 0;}var imgRGBArray = new int[1920][];bitmap.GetRGB(0, 0, 1080, 1920, imgRGBArray);var chessPoint = GetMySelfChessPosition(imgRGBArray);var targetPoint = FindTargetPoint(imgRGBArray);return calcSpace(chessPoint, targetPoint); 计算目标点坐标如何计算目标点坐标是个比较困难的问题, 最开始想的是扫描图片, 取最上方的节点颜色, 然后从该点开始取周围所有相同颜色的坐标, 最后求平均值就能得到中心点即目标点坐标了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990private Point FindTargetPoint(int[][] imgRGBArray){ //从500开始逐行扫描 RGB tempRGB; RGB tempBoxColorRGB = new RGB(); Point startPoint = new Point(0, 0); Point endPoint = new Point(0, 0); Point rightPoint = new Point(0, 0); int rightHeight = 0; int maybeHeight = 0; var isFindStart = false; var isInBox = true; var isFindRight = false; var findCount = 400; var currentRowMaxJ = 0; for (var i = 500; i &lt; imgRGBArray.Length; i++) { currentRowMaxJ = 0; for (var j = 0; j &lt; imgRGBArray[i].Length; j++) { tempRGB = RGB.FromInt(imgRGBArray[i][j]); if (!isFindStart) { if (!IsBgColor(tempRGB)) { isFindStart = true; startPoint.Y = i; startPoint.X = j; endPoint.X = j; rightPoint.X = j; tempBoxColorRGB = tempRGB; imgRGBArray[i][j] = (~tempRGB).ToInt(); currentRowMaxJ = j; } } else if (findCount &gt;= 0) { if (RGB.FromInt(imgRGBArray[i][j]) == tempBoxColorRGB) { currentRowMaxJ = j; if (!isFindRight) { imgRGBArray[i][j] = (~tempBoxColorRGB).ToInt(); } else if (isFindRight &amp;&amp; (i - startPoint.Y) &lt; (2 * maybeHeight + 20)) { imgRGBArray[i][j] = (~tempBoxColorRGB).ToInt(); endPoint.Y = i; } else if (isFindRight &amp;&amp; (i - startPoint.Y) &gt;= (2 * maybeHeight + 20)) { isInBox = false; break; } } } } if (isFindStart) { findCount--; //该行循环完成 if (rightPoint.X &lt; currentRowMaxJ) { rightPoint.X = currentRowMaxJ; rightPoint.Y = i; rightHeight = 0; } else if (rightPoint.X == currentRowMaxJ) { rightHeight++; } else if (rightPoint.X &gt; currentRowMaxJ) { isFindRight = true; maybeHeight = rightPoint.Y - startPoint.Y + rightHeight / 2; } } if (findCount &lt; 0 || !isInBox) { break; } } return new Point((startPoint.X + endPoint.X) / 2, (startPoint.Y + endPoint.Y) / 2);} 但是这样做了以后, 发现的问题是… 跳到后面一点以后, 有颜色完全不同的方块出来了… 忘记了这一点, 如果改成全用非背景识别区域, 那么后期也会存在一个问题, 距离特别近的时候, 棋子会覆盖住这片空白空间, 用非背景色判断也会存在问题. 那么就只能换种思路了. 再从头分析一下, 跳一步以后, 下一个方块从上方落下, 随机一个点, 但是一定是最上方, 那么换一种计算方式, 先找到目标物的顶点, 而光照是从右边往左边的, 那么下一步去找目标物的右端点, 如果右端点被棋子挡住了, 说明棋子在右边, 然后去寻找左端点, 就不会出现左端点被阴影挡住了的情况. 那么接下来的分析函数就简单了, 分成几个小函数实现. 寻找顶点坐标这里有个要注意的情况, 即棋子最高点有可能是比顶点还高的, 需要处理下这种情况, 所以需要先找到棋子位置再传入. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/// &lt;summary&gt;/// 寻找顶点的方法/// &lt;/summary&gt;/// &lt;param name=&quot;imgRGBArray&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;chessPoint&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private Point FindTopPoint(int[][] imgRGBArray, Point chessPoint){ RGB tempRGB; Point topPoint = new Point(0, 0); var hasFindTopPoint = false; var isFirstFindIsNotBg = 0; for (var i = 500; i &lt; imgRGBArray.Length; i++) { for (var j = 0; j &lt; imgRGBArray[i].Length; j++) { isFirstFindIsNotBg++; if (!hasFindTopPoint) { tempRGB = RGB.FromInt(imgRGBArray[i][j]); //if (!IsBgColor(tempRGB) &amp;&amp; !tempRGB.TotalLike(SelfCheesColor, 30)) if (!IsBgColor(tempRGB)) { if (isFirstFindIsNotBg == 1) { MessageBox.Show(string.Format(&quot;第一个点就不是BG,出错,BG颜色:{0},当前点颜色:{1}&quot;, BgColorAverage, tempRGB)); return ErrorPoint; } //如果当前点在自己点的空间中 if ((j &gt; chessPoint.X - 32) &amp;&amp; (j &lt; chessPoint.X + 50) &amp;&amp; (i &gt; chessPoint.Y - 2) &amp;&amp; (i &lt; chessPoint.Y + 200)) { continue; } else { hasFindTopPoint = true; topPoint.Y = i; topPoint.X = j; break; } } } } if (hasFindTopPoint) { break; } } if (!hasFindTopPoint) { MessageBox.Show(&quot;未找到合适的顶点&quot;); return ErrorPoint; } return topPoint;} 寻找右端点坐标12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/// &lt;summary&gt;/// 先寻找右端点, 如果未找到或者右端点在自己棋子区间, 返回ErrorPoint/// &lt;/summary&gt;/// &lt;param name=&quot;imgRGBArray&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;chessPoint&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;topPoint&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private Point FindRightPoint(int[][] imgRGBArray, Point chessPoint, Point topPoint){ RGB tempRGB; var currentBGColor = new RGB(imgRGBArray[topPoint.Y - 3][topPoint.X]); //从顶点开始往右边找 //最高高度设置为200 var maxHeight = 200; var maxWidth = 300; Point rightPoint = new Point(0, 0); var hasFindRightPoint = false; for (var i = topPoint.Y; i &lt; topPoint.Y + maxHeight; i++) { var thisRowIsAllBG = true; var currentRowHasBgInMiddle = false; for (var j = topPoint.X; j &lt; topPoint.X + maxWidth &amp;&amp; j &lt; imgRGBArray[i].Length; j++) { if (!hasFindRightPoint) { tempRGB = RGB.FromInt(imgRGBArray[i][j]); //如果当前点是背景颜色, 跳过该行 if (!thisRowIsAllBG &amp;&amp; tempRGB.Like(currentBGColor, 10)) { currentRowHasBgInMiddle = true; } if (!IsBgColor(tempRGB)) { thisRowIsAllBG = false; //如果当前点不是背景,而下一个点是背景 if (!currentRowHasBgInMiddle &amp;&amp; IsBgColor(RGB.FromInt(imgRGBArray[i][j + 1]))) { if (rightPoint.X &lt; j)//如果已经有的rightPoint在当前点左边 { rightPoint.Y = i; rightPoint.X = j; } else if (rightPoint.X == j) { //如果已有的rightPoint和当前点的X坐标相同, //那么需要接下来的几个点都不是背景,才能确定是最终点 var isFinal = true; for (int m = 1; m &lt; 3; m++) { if (!IsBgColor(RGB.FromInt(imgRGBArray[i + m][j + 1]))) { isFinal = false; break; } } if (isFinal) { hasFindRightPoint = true; break; } } else if (rightPoint.X &gt; j) { hasFindRightPoint = true; break; } } } } } if (hasFindRightPoint) { break; } } if (!hasFindRightPoint) { return ErrorPoint; //MessageBox.Show(&quot;未找到合适的右端点, 去寻找左端点&quot;); } return rightPoint;} 寻找左端点坐标1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/// &lt;summary&gt;/// 如果右端点不存在或者出错的情况下, 开始寻找左端点/// &lt;/summary&gt;/// &lt;param name=&quot;imgRGBArray&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;chessPoint&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;topPoint&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private Point FindLeftPoint(int[][] imgRGBArray, Point chessPoint, Point topPoint){ var currentBGColor = new RGB(imgRGBArray[topPoint.Y - 3][topPoint.X]); var topPointColor = RGB.FromInt(imgRGBArray[topPoint.Y][topPoint.X]); //从顶点开始往右边找 //最高高度设置为200 var maxHeight = 200; var hasFindLeftPoint = false; var leftPoint = new Point(0, 0); //寻找左边端点 for (var i = topPoint.Y; i &lt; topPoint.Y + maxHeight; i++) { for (var j = 100; j &lt; topPoint.X; j++) { if (!hasFindLeftPoint) { //如果当前点不是背景色 if (!RGB.FromInt(imgRGBArray[i][j]).Like(currentBGColor, 10)) { //如果以下8个点都不是背景, //而且前一位的8个点都是背景 //那么就是左端点 var isFinal = true; for (var m = 1; m &lt;= 8; m++) { if (!RGB.FromInt(imgRGBArray[i + m][j - 1]).Like(currentBGColor, 10) || RGB.FromInt(imgRGBArray[i + m][j]).Like(currentBGColor, 10)) { isFinal = false; break; } } if (isFinal) { leftPoint.Y = i; leftPoint.X = j; hasFindLeftPoint = true; break; } } } } if (hasFindLeftPoint) { break; } } if (!hasFindLeftPoint) { return ErrorPoint; } return leftPoint;} 寻找自己棋子坐标这个坐标寻找方式就和之前的找目标点完全不同了, 因为棋子是不会变化的, 那么从PS中截出棋子的图片, 然后当作res把图片信息加载进来, 再整个图片查找一下对应点和像素, 就能找到自己的点了. 需要注意的是, 为了防止色差, 对自己棋子的点的颜色比较设定了一个容差5. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#region 棋子位置和颜色函数private RGB[][] imgMySelfChessRGBColorArray;private RGB[][] mySelfChessStart3x3Point;private void InitMyImgARGBArray(){ var bitmap = (Bitmap)Image.FromFile(PublicPath + @&quot;/Res/WX-MY.png&quot;); if (bitmap.Width != 80 || bitmap.Height != 220) { MessageBox.Show(&quot;资源图片错误&quot;); return; } var imgMySelfRGBArray = new long[220][]; Point StartPoint = new Point(-1, -1); imgMySelfChessRGBColorArray = new RGB[imgMySelfRGBArray.Length][]; bitmap.GetRGBA(0, 0, 80, 220, imgMySelfRGBArray); for (var i = 0; i &lt; imgMySelfRGBArray.Length; i++) { imgMySelfChessRGBColorArray[i] = new RGB[imgMySelfRGBArray[i].Length]; for (var j = 0; j &lt; imgMySelfRGBArray[i].Length; j++) { var tempRGB = RGB.FromInt(imgMySelfRGBArray[i][j], true); imgMySelfChessRGBColorArray[i][j] = tempRGB; if (tempRGB.A == 255 &amp;&amp; StartPoint.X == -1) { StartPoint.Y = i; StartPoint.X = j; } } } mySelfChessStart3x3Point = new RGB[3][]; for (var i = 0; i &lt; mySelfChessStart3x3Point.Length; i++) { mySelfChessStart3x3Point[i] = new RGB[3]; for (var j = 0; j &lt; mySelfChessStart3x3Point[i].Length; j++) { mySelfChessStart3x3Point[i][j] = imgMySelfChessRGBColorArray[StartPoint.Y + i][StartPoint.X + j]; } }}private Point GetMySelfChessPosition(int[][] imgRGBArray){ int temp_i = 0; int temp_j = 0; RGB tempRGB = new RGB(); var isFindStart = false; var findCount = 50; for (var i = 500; i &lt; 1500; i++) { for (var j = 100; j &lt; 1000; j++) { tempRGB = RGB.FromInt(imgRGBArray[i][j]); if (!isFindStart) { if (IsMySelfChess(imgRGBArray, i, j)) { isFindStart = true; temp_i = i; temp_j = j; } } } if (isFindStart) { findCount--; } if (findCount &lt; 0) { break; } } return new Point(temp_j, temp_i);}private bool IsMySelfChess(int[][] imgRGBArray, int _i, int _j){ for (var i = 0; i &lt; mySelfChessStart3x3Point.Length; i++) { for (var j = 0; j &lt; mySelfChessStart3x3Point[i].Length; j++) { if (!mySelfChessStart3x3Point[i][j].Like(RGB.FromInt(imgRGBArray[_i + i][_j + j]), 5)) { return false; } } } return true;}#endregion 计算距离最开始直接使用的两点距离计算公式, 后来发现可能需要只计算轴向距离的间隔. 但是最终测试以后, 发现直接计算距离好像也可以. 12345678//计算轴向距离var l = Math.Sqrt(Math.Pow(targetPoint.X - cheesCenterPoint.X, 2) + Math.Pow(targetPoint.Y - cheesCenterPoint.Y, 2));var angle = Math.Atan2(Math.Abs(targetPoint.Y - cheesCenterPoint.Y), Math.Abs(targetPoint.X - cheesCenterPoint.X)) * 180 / Math.PI;var space = l * Math.Cos((angle - 30) * Math.PI / 180);//计算点距离var space = Math.Sqrt(Math.Pow(targetPoint.X - cheesCenterPoint.X, 2) + Math.Pow(targetPoint.Y - cheesCenterPoint.Y, 2)); 计算跳跃时间这个值…纯粹靠猜和试, 毕竟分辨率不同, 测出来的像素距离也会不同… 123456789101112131415/// &lt;summary&gt;/// 根据距离计算按压时间/// * 可能距离超过一定长度的时候需要减少按压时间/// &lt;/summary&gt;/// &lt;param name=&quot;space&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public int GetPressTimeBySpace(double space){ double result = space * 1.4; if (space &gt; 600) { result = space * 1.35; } return (int)(result);} 优化&amp;流程到这里以后, 基本上功能就完成了, 然后添加一些小的修补功能和自动化流程以后, 就能使用了. 不过还有个优化的地方, 就是在一次跳在正中心点以后, 下一个目标物上会出现一个白色小圈圈, 表示跳那里能出现2x加分. 利用好这个点, 可以极大的缩减点位计算幅度. 那么流程就变成如下: 寻找自己点坐标; 寻找顶点坐标(需要排除自己的位置); 试图根据顶点坐标寻找白圈; 如果找到白圈 -&gt; 返回; 如果没找到, 寻找右端点; 如果右端点不存在或者被自己挡住, 寻找左端点; 根据端点计算出目标点距离, 返回; 试图寻找中心白圈123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186/// &lt;summary&gt;/// 试图寻找下一步中间的白点(如果上一步是中心点)/// 从顶点开始, 寻找整个可能的格子空间,/// 记录所有颜色值为白点的点./// 如果这些点最终能构成符合大小的圆形,/// 那么可以确定为中心点./// &lt;/summary&gt;/// &lt;param name=&quot;imgRGBArray&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;chessPoint&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;topPoint&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private Point TryFindCenterWhitePoint(int[][] imgRGBArray, Point chessPoint, Point topPoint){ var currentBGColor = new RGB(imgRGBArray[topPoint.Y - 3][topPoint.X]); //从顶点开始往右边找 //最高高度设置为200 var maxHeight = 200; var maxWidth = 300; Point centerPoint = new Point(0, 0); var hasFindCenterPoint = false; for (var i = topPoint.Y; i &lt; topPoint.Y + maxHeight; i++) { for (var j = topPoint.X; j &lt; topPoint.X + maxWidth; j++) { if (!hasFindCenterPoint) { if (topPoint.X - j &gt; 0 &amp;&amp; RGB.FromInt(imgRGBArray[i][topPoint.X - j]) == TargetCenterWhitePointColor) { var centerPointMay = TryFindWhiteCircleAtPosition(imgRGBArray, i, topPoint.X - j); if (centerPointMay == ErrorPoint) { break; } else { centerPoint = centerPointMay; hasFindCenterPoint = true; } } if (j &lt; imgRGBArray[i].Length &amp;&amp; RGB.FromInt(imgRGBArray[i][j]) == TargetCenterWhitePointColor) { var centerPointMay = TryFindWhiteCircleAtPosition(imgRGBArray, i, j); if (centerPointMay == ErrorPoint) { break; } else { centerPoint = centerPointMay; hasFindCenterPoint = true; } } } } if (hasFindCenterPoint) { break; } } if (hasFindCenterPoint) { return centerPoint; } return ErrorPoint;}/// &lt;summary&gt;/// 在指定坐标(白色圆形顶部)判断是否能找到白色圆形/// &lt;/summary&gt;/// &lt;param name=&quot;imgRGBArray&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;_i&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;_j&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private Point TryFindWhiteCircleAtPosition(int[][] imgRGBArray, int _i, int _j){ var maxWhiteCircleHeight = 28; var maxWhiteCircleWidth = 45; var startPointSpaceBetweenCircle = maxWhiteCircleWidth / 2; var minWhiteCircleHeight = 20; var minWhiteCircleWidth = 35; var leftTopPoint = new Point(1920 - 1, 1080 - 1); var rightBottomPoint = new Point(0, 0); var centerPoint = new Point(0, 0); var centerPointAddCount = 0; //根据平均统计,找到最中心的点 for (var i = _i; i &lt; _i + maxWhiteCircleHeight; i++) { for (var j = _j - startPointSpaceBetweenCircle; j &lt; _j + maxWhiteCircleWidth + startPointSpaceBetweenCircle; j++) { if (j &lt; 0 || j &gt; imgRGBArray[0].Length) { continue; } if (RGB.FromInt(imgRGBArray[i][j]) == TargetCenterWhitePointColor) { leftTopPoint.Y = Math.Min(leftTopPoint.Y, i); leftTopPoint.X = Math.Min(leftTopPoint.X, j); rightBottomPoint.Y = Math.Max(rightBottomPoint.Y, i); rightBottomPoint.X = Math.Max(rightBottomPoint.X, j); centerPoint.Y += i; centerPoint.X += j; centerPointAddCount++; } } } centerPoint = new Point(centerPoint.X / centerPointAddCount, centerPoint.Y / centerPointAddCount); var middlePoint = new Point((leftTopPoint.X + rightBottomPoint.X) / 2, (leftTopPoint.Y + rightBottomPoint.Y) / 2); //判断该点周围全是白色 for (var i = centerPoint.Y - 3; i &lt;= centerPoint.Y + 3; i++) { for (var j = centerPoint.X - 10; j &lt;= centerPoint.X + 10; j++) { if (RGB.FromInt(imgRGBArray[i][j]) != TargetCenterWhitePointColor) { return ErrorPoint; } } } //最大距离之外不是白色, 最小距离之内全是白色 if (RGB.FromInt(imgRGBArray[centerPoint.Y - maxWhiteCircleHeight / 2][centerPoint.X]) == TargetCenterWhitePointColor) { return ErrorPoint; } if (RGB.FromInt(imgRGBArray[centerPoint.Y + maxWhiteCircleHeight / 2][centerPoint.X]) == TargetCenterWhitePointColor) { return ErrorPoint; } if (RGB.FromInt(imgRGBArray[centerPoint.Y][centerPoint.X - maxWhiteCircleWidth / 2]) == TargetCenterWhitePointColor) { return ErrorPoint; } if (RGB.FromInt(imgRGBArray[centerPoint.Y][centerPoint.X + maxWhiteCircleWidth / 2]) == TargetCenterWhitePointColor) { return ErrorPoint; } if (RGB.FromInt(imgRGBArray[centerPoint.Y - minWhiteCircleHeight / 2][centerPoint.X]) != TargetCenterWhitePointColor) { return ErrorPoint; } if (RGB.FromInt(imgRGBArray[centerPoint.Y + minWhiteCircleHeight / 2][centerPoint.X]) != TargetCenterWhitePointColor) { return ErrorPoint; } if (RGB.FromInt(imgRGBArray[centerPoint.Y][centerPoint.X - minWhiteCircleWidth / 2]) != TargetCenterWhitePointColor) { return ErrorPoint; } if (RGB.FromInt(imgRGBArray[centerPoint.Y][centerPoint.X + minWhiteCircleWidth / 2]) != TargetCenterWhitePointColor) { return ErrorPoint; } //最大边框处不应该有白色 if (RGB.FromInt(imgRGBArray[leftTopPoint.Y][leftTopPoint.X]) == TargetCenterWhitePointColor) { return ErrorPoint; } if (RGB.FromInt(imgRGBArray[leftTopPoint.Y][rightBottomPoint.X]) == TargetCenterWhitePointColor) { return ErrorPoint; } if (RGB.FromInt(imgRGBArray[rightBottomPoint.Y][rightBottomPoint.X]) == TargetCenterWhitePointColor) { return ErrorPoint; } if (RGB.FromInt(imgRGBArray[rightBottomPoint.Y][leftTopPoint.X]) == TargetCenterWhitePointColor) { return ErrorPoint; } SetPointWithRectColor(imgRGBArray, leftTopPoint.Y, leftTopPoint.X, 3, CenterBoxColor); SetPointWithRectColor(imgRGBArray, leftTopPoint.Y, rightBottomPoint.X, 3, CenterBoxColor); SetPointWithRectColor(imgRGBArray, rightBottomPoint.Y, rightBottomPoint.X, 3, CenterBoxColor); SetPointWithRectColor(imgRGBArray, rightBottomPoint.Y, leftTopPoint.X, 3, CenterBoxColor); return centerPoint;} 自动化开启一个新线程执行循环跳, 再点一次干掉线程. 1234567891011121314151617181920212223242526272829private void BtnStartJump_Click(object sender, EventArgs e){ isDoingJump = !isDoingJump; if (isDoingJump) { myLog.AppendToFile(LogFilePath, &quot;开始跳...&quot;); BtnStartJump.Text = &quot;正在跳...&quot;; jumpThread = new Thread(() =&gt; { while (isDoingJump) { GetAndroidScreen(); var space = AnalyseSpace(); System.Threading.Thread.Sleep(JumpDelay); var pressTime = GetPressTimeBySpace(space); ExecCmd(ADBPath + string.Format(&quot;shell input swipe 500 500 501 501 {0}&quot;, pressTime)); System.Threading.Thread.Sleep(pressTime + ShotScreenDelay); } }); jumpThread.Start(); } else { myLog.AppendToFile(LogFilePath, &quot;跳完了&quot;); BtnStartJump.Text = &quot;开始跳!&quot;; jumpThread.Abort(); jumpThread = null; }} 日志记录然后就是加入日志模块, 和图片保存, 将每次跳和计算的结果都保存起来, 以供之后分析. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class JumpLog{ public JumpLog() { } public JumpLog(DateTime shotScreenTime) { this.ShotScreenTime = shotScreenTime; } public DateTime ShotScreenTime { get; set; } public DateTime AnalyseStartTime { get; set; } public DateTime AnalyseEndTime { get; set; } public int AnalyseTime { get { return (int)(AnalyseEndTime - AnalyseStartTime).TotalMilliseconds; } } public double AnalyseSpace { get; set; } public Point TopPointPosition { get; set; } public Point RightPointPosition { get; set; } public Point LeftPointPosition { get; set; } public Point CenterWhitePointPosition { get; set; } public JumpLogPointPositionType GetPointPositionType { get; set; } public Point TargetPointPosition { get; set; } public Point SelfChessPointPosition { get; set; } public int PressTime { get; set; } public string ScreenImageFileName { get; set; } public void AppendToFile(string filePath, string content) { using (var fileStream = File.Open(filePath, FileMode.Append, FileAccess.Write)) { var writeStream = new StreamWriter(fileStream, Encoding.UTF8); writeStream.WriteLine(string.Format(&quot;[{0}] : {1}&quot;, DateTime.Now.GetCommonDateString(), content)); writeStream.Flush(); writeStream.Close(); } } public void AppendToFile(string filePath) { AppendToFile(filePath, GetLogString()); } private string GetLogString() { return string.Format(&quot;[截图时间:{0}] [分析耗时:{1}ms] [分析最终距离:{2}px] [按压时间:{3}] [定位模式:{4}] [顶点坐标:{5}] [定位点坐标:{6}] [目标点坐标:{7}] [棋子坐标:{8}] [图片名称:{9}]&quot;, ShotScreenTime.GetCommonDateString(), AnalyseTime, AnalyseSpace.ToString(&quot;0.00&quot;), PressTime, GetPointPositionType.GetDescription(), TopPointPosition.ToString(), GetRightAnchorPointPosition().ToString(), TargetPointPosition.ToString(), SelfChessPointPosition.ToString(), ScreenImageFileName); } private Point GetRightAnchorPointPosition() { switch (GetPointPositionType) { case JumpLogPointPositionType.Center: return CenterWhitePointPosition; case JumpLogPointPositionType.Right: return RightPointPosition; case JumpLogPointPositionType.Left: return LeftPointPosition; } return new Point(-1, -1); }}public enum JumpLogPointPositionType{ [Description(&quot;通过中心白点定位&quot;)] Center = 1, [Description(&quot;通过右端点定位&quot;)] Right = 2, [Description(&quot;通过左端点定位&quot;)] Left = 4,}public static class StaticJumpLogPointPositionTypeHelp{ public static string GetDescription(this JumpLogPointPositionType type) { FieldInfo EnumInfo = type.GetType().GetField(type.ToString()); DescriptionAttribute[] EnumAttributes = (DescriptionAttribute[])EnumInfo. GetCustomAttributes(typeof(DescriptionAttribute), false); if (EnumAttributes.Length &gt; 0) { return EnumAttributes[0].Description; } return type.ToString(); }} 运行结果","link":"/2018/2018-01-08-wechat-jump-game/"}],"tags":[{"name":"ann","slug":"ann","link":"/tags/ann/"},{"name":"backpropagation","slug":"backpropagation","link":"/tags/backpropagation/"},{"name":"dynamic","slug":"dynamic","link":"/tags/dynamic/"},{"name":"programming","slug":"programming","link":"/tags/programming/"},{"name":"angular","slug":"angular","link":"/tags/angular/"},{"name":"provider","slug":"provider","link":"/tags/provider/"},{"name":"angularCss","slug":"angularCss","link":"/tags/angularCss/"},{"name":"directive","slug":"directive","link":"/tags/directive/"},{"name":"ui-router","slug":"ui-router","link":"/tags/ui-router/"},{"name":"async-module","slug":"async-module","link":"/tags/async-module/"},{"name":"eval","slug":"eval","link":"/tags/eval/"},{"name":"watch","slug":"watch","link":"/tags/watch/"},{"name":"scope","slug":"scope","link":"/tags/scope/"},{"name":"controller","slug":"controller","link":"/tags/controller/"},{"name":"service","slug":"service","link":"/tags/service/"},{"name":"chrome","slug":"chrome","link":"/tags/chrome/"},{"name":"extension","slug":"extension","link":"/tags/extension/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"oracle","slug":"oracle","link":"/tags/oracle/"},{"name":"sqlserver","slug":"sqlserver","link":"/tags/sqlserver/"},{"name":"split","slug":"split","link":"/tags/split/"},{"name":"function","slug":"function","link":"/tags/function/"},{"name":"sublime","slug":"sublime","link":"/tags/sublime/"},{"name":"plugins","slug":"plugins","link":"/tags/plugins/"},{"name":"css3","slug":"css3","link":"/tags/css3/"},{"name":"flex","slug":"flex","link":"/tags/flex/"},{"name":".net","slug":"net","link":"/tags/net/"},{"name":"c#","slug":"c","link":"/tags/c/"},{"name":"regex","slug":"regex","link":"/tags/regex/"},{"name":"group","slug":"group","link":"/tags/group/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"redis","slug":"redis","link":"/tags/redis/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"import","slug":"import","link":"/tags/import/"},{"name":"module","slug":"module","link":"/tags/module/"},{"name":"SqlServer","slug":"SqlServer","link":"/tags/SqlServer/"},{"name":"GroupBy","slug":"GroupBy","link":"/tags/GroupBy/"},{"name":"PartitionBy","slug":"PartitionBy","link":"/tags/PartitionBy/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"jsx","slug":"jsx","link":"/tags/jsx/"},{"name":"component","slug":"component","link":"/tags/component/"},{"name":"router","slug":"router","link":"/tags/router/"},{"name":"redux","slug":"redux","link":"/tags/redux/"},{"name":"immutable","slug":"immutable","link":"/tags/immutable/"},{"name":"decorator","slug":"decorator","link":"/tags/decorator/"},{"name":"context","slug":"context","link":"/tags/context/"},{"name":"ng-cmd","slug":"ng-cmd","link":"/tags/ng-cmd/"},{"name":"data-binding","slug":"data-binding","link":"/tags/data-binding/"},{"name":"once-bind","slug":"once-bind","link":"/tags/once-bind/"},{"name":"async","slug":"async","link":"/tags/async/"},{"name":"redux-form","slug":"redux-form","link":"/tags/redux-form/"},{"name":"file","slug":"file","link":"/tags/file/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"flowjs","slug":"flowjs","link":"/tags/flowjs/"},{"name":"WebAssembly","slug":"WebAssembly","link":"/tags/WebAssembly/"},{"name":"quantum","slug":"quantum","link":"/tags/quantum/"},{"name":"computing","slug":"computing","link":"/tags/computing/"},{"name":"xposed","slug":"xposed","link":"/tags/xposed/"},{"name":"sport","slug":"sport","link":"/tags/sport/"},{"name":"editor","slug":"editor","link":"/tags/editor/"},{"name":"react-native","slug":"react-native","link":"/tags/react-native/"},{"name":"wechat","slug":"wechat","link":"/tags/wechat/"},{"name":"game","slug":"game","link":"/tags/game/"},{"name":"plugin","slug":"plugin","link":"/tags/plugin/"}],"categories":[{"name":"Plugins","slug":"Plugins","link":"/categories/Plugins/"},{"name":"Other","slug":"Plugins/Other","link":"/categories/Plugins/Other/"}]}